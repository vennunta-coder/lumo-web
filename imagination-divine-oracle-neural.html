<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>IMAGINATION — DIVINE ORACLE (Neural TTS-ready)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; background:#0e0e10; color:#e9f6f1; overflow:hidden; }
    canvas { display:block; }
    #overlay { position:fixed; inset:0; pointer-events:none; z-index:5; }
    #caption {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 18px; z-index: 10; pointer-events: none;
      background: rgba(0,0,0,.45); color: #e7ffe7;
      font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding: 8px 10px; border-radius: 10px; max-width: 92vw; text-align:center;
      box-shadow: 0 8px 24px rgba(0,0,0,.28);
    }
    #hint { position: fixed; inset: 0; display:flex; align-items:center; justify-content:center; z-index: 11;
      font: 14px system-ui; color:#dfe; background: rgba(0,0,0,.55); text-align:center; padding: 20px }
    #hint .card{ background:#101919; border:1px solid #1d2b2b; border-radius: 14px; padding: 16px 18px; max-width: 520px }
    #hint small{ display:block; margin-top:6px; color:#a7c3c3 }
    #consent { position: fixed; inset: 0; display:flex; align-items:center; justify-content:center; z-index: 12;
      font: 14px system-ui; color:#e9f6f1; background: rgba(0,0,0,.65); }
    #consent .panel{ background:#0f1414; border:1px solid #243; border-radius:14px; padding:16px 18px; max-width:560px }
    #consent label{ display:flex; gap:8px; align-items:center; margin:6px 0 }
    #consent button{ background:#172020; color:#e9f6f1; border:1px solid #2c3f3f; border-radius:10px; padding:8px 12px; cursor:pointer }
    #secret { position: fixed; right: 12px; top: 12px; z-index: 13; display:none;
      background:#0c1212cc; border:1px solid #1b2a2a; border-radius:12px; padding:10px 12px; font: 12px system-ui; }
    #secret label{ display:flex; gap:6px; align-items:center; margin:6px 0 }
    #secret input, #secret select { background:#080d0d; color:#dfe; border:1px solid #223; border-radius:8px; padding:4px 6px }
    #secret small{ color:#9dc }
  </style>
</head>
<body>
  <div id="hint">
    <div class="card">
      <div>Toque em qualquer lugar para ativar o áudio. A câmara/microfone pedirão permissão quando necessário.</div>
      <small>Processamento local: nada sai do teu dispositivo sem consentimento explícito.</small>
    </div>
  </div>

  <div id="consent">
    <div class="panel">
      <b>Consentimento</b>
      <label><input id="consCam" type="checkbox" checked> Usar câmara para emoções (on-device)</label>
      <label><input id="consMic" type="checkbox" checked> Usar microfone para ouvir pedidos (STT, quando suportado)</label>
      <label><input id="consGeo" type="checkbox"> Pedir localização aproximada (Geolocation API)</label>
      <label><input id="consTTS" type="checkbox" checked> Falar contigo (TTS) — pode usar vozes neurais via servidor próprio</label>
      <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap">
        <button id="consAccept">Aceito</button>
        <button id="consReject">Rejeito</button>
      </div>
      <small>Sem “IA militar”, sem rastreio invasivo ou tentativa de “descobrir tudo” sobre ti. Só o que tu aprovares.</small>
    </div>
  </div>

  <div id="caption" role="status" aria-live="polite">A invocar o Oráculo…</div>
  <canvas id="c"></canvas>
  <canvas id="overlay"></canvas>
  <video id="video" playsinline autoplay muted style="display:none"></video>

  <!-- Secret settings (press S) -->
  <div id="secret">
    <div><b>Definições secretas</b> (tecla S)</div>
    <label>Idioma: <select id="langSel"></select></label>
    <label>Persona: 
      <select id="personaSel">
        <option value="auto">auto</option>
        <option value="woman">mulher</option>
        <option value="man">homem</option>
        <option value="child">criança</option>
      </select>
    </label>
    <label>Modo de voz:
      <select id="ttsMode">
        <option value="webspeech" selected>Web Speech (local)</option>
        <option value="server">Neural (via /api/tts)</option>
      </select>
    </label>
    <label>Voz TTS local: <select id="voiceSel"></select></label>
    <label><input id="ancientMix" type="checkbox" checked> Misturar línguas antigas</label>
    <label><input id="sttToggle" type="checkbox" checked> Ouvir a tua voz (STT)</label>
    <small>Para vozes hiper-realistas, ative “Neural (via /api/tts)” e configure o servidor com a sua API de TTS.</small>
  </div>

  <script type="module">
    // ===== Basics =====
    const canvas = document.getElementById('c');
    const overlay = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const octx = overlay.getContext('2d');
    const caption = document.getElementById('caption');
    const hint = document.getElementById('hint');
    const consentEl = document.getElementById('consent');

    const WORD = "IMAGINATION";
    const PRESET = { dot:"#ffffff", left:"#111111", right:"#e9e9e9", scatter:2.6, font:"Montserrat", size: 120 };

    function setCaption(t){ caption.textContent = t; }
    function toggleSecret(){ secret.style.display = (secret.style.display==='none' || !secret.style.display)?'block':'none'; }
    const secret = document.getElementById('secret');

    // Consent
    const cons = {
      cam: document.getElementById('consCam'),
      mic: document.getElementById('consMic'),
      geo: document.getElementById('consGeo'),
      tts: document.getElementById('consTTS'),
      accept: document.getElementById('consAccept'),
      reject: document.getElementById('consReject')
    };
    cons.accept.addEventListener('click', ()=>{ consentEl.style.display='none'; boot(); });
    cons.reject.addEventListener('click', ()=>{
      // Disable all features if rejected
      cons.cam.checked = cons.mic.checked = cons.geo.checked = cons.tts.checked = false;
      consentEl.style.display='none'; boot(); 
    });

    // Keyboard
    window.addEventListener('keydown', (e)=>{ if (e.key.toLowerCase()==='s') toggleSecret(); });

    // Canvas particles
    let GAP = 4, SIZE = 2, RETURN_SPEED = 20, SCATTER = PRESET.scatter;
    let FONT = ()=> `bold ${PRESET.size}px ${PRESET.font}`;
    let particleColor = PRESET.dot, bgLeft = PRESET.left, bgRight = PRESET.right;
    const mouse = { x: -9999, y: -9999, radius: 90 };
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mouseleave', () => { mouse.x = -9999; mouse.y = -9999; });

    function resize() {
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      for (const cvs of [canvas, overlay]) {
        cvs.width = innerWidth * dpr; cvs.height = innerHeight * dpr;
        cvs.style.width = innerWidth + 'px'; cvs.style.height = innerHeight + 'px';
        const ctx2d = cvs.getContext('2d'); ctx2d.setTransform(dpr,0,0,dpr,0,0);
      }
      init();
    }
    window.addEventListener('resize', resize);

    let particles = [];
    class Particle {
      constructor(x, y) { this.baseX = x; this.baseY = y; this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.size = SIZE; this.alpha = 1; this.dead = false; this.density = Math.random()*40 + 10; }
      draw(){ if (this.dead) return; ctx.globalAlpha = this.alpha; ctx.fillStyle = particleColor; ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1; }
      update(){
        if (this.dead) return;
        const dx = mouse.x - this.x, dy = mouse.y - this.y, dist = Math.hypot(dx, dy);
        if (dist < mouse.radius) {
          const force = (mouse.radius - dist) / mouse.radius;
          const dirX = dx / (dist || 1), dirY = dy / (dist || 1);
          this.x -= dirX * force * this.density; this.y -= dirY * force * this.density;
          this.vx -= dirX * SCATTER * Math.random(); this.vy -= dirY * SCATTER * Math.random();
        } else {
          if (this.x !== this.baseX) this.x -= (this.x - this.baseX) / RETURN_SPEED;
          if (this.y !== this.baseY) this.y -= (this.y - this.baseY) / RETURN_SPEED;
        }
        this.x += this.vx; this.y += this.vy; this.vx *= 0.92; this.vy *= 0.92;
      }
    }
    function bg(){
      const midX = innerWidth / 2;
      ctx.fillStyle = bgLeft; ctx.fillRect(0,0,midX,innerHeight);
      ctx.fillStyle = bgRight; ctx.fillRect(midX,0,innerWidth - midX, innerHeight);
    }
    function init() {
      ctx.clearRect(0,0,innerWidth,innerHeight);
      ctx.save(); ctx.font = FONT(); ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; bg(); ctx.fillStyle = '#fff'; ctx.shadowColor = 'rgba(0,0,0,.35)'; ctx.shadowBlur = 6; ctx.fillText(WORD, innerWidth/2, innerHeight/2); ctx.restore();
      const img = ctx.getImageData(0, 0, innerWidth, innerHeight).data; particles = [];
      for (let y = 0; y < innerHeight; y += GAP) for (let x = 0; x < innerWidth; x += GAP) { const i = (y * innerWidth + x) * 4; if (img[i+3] > 128) particles.push(new Particle(x,y)); }
    }
    function animate() {
      ctx.clearRect(0,0,innerWidth,innerHeight); bg();
      const grad = ctx.createLinearGradient(innerWidth*0.55,0,innerWidth,0); grad.addColorStop(0,'rgba(255,255,255,0)'); grad.addColorStop(1,'rgba(255,255,255,0.08)');
      ctx.fillStyle = grad; ctx.fillRect(innerWidth*0.55,0,innerWidth*0.45,innerHeight);
      for (let p of particles) { p.size = SIZE; p.update(); p.draw(); }
      requestAnimationFrame(animate);
    }
    function start() { resize(); animate(); }
    start();

    // ===== Music (ambient) =====
    let musicEngine = null;
    class Music {
      constructor(){
        this.ctx = new (window.AudioContext||window.webkitAudioContext)();
        this.master = this.ctx.createGain(); this.master.gain.value = 0.26; this.master.connect(this.ctx.destination);
        this.dest = this.ctx.createMediaStreamDestination(); this.master.connect(this.dest);
        this.loopHandle = null;
      }
      getStream(){ return this.dest.stream; }
      async start(){
        if (this.ctx.state === 'suspended') await this.ctx.resume();
        if (this.loopHandle) return;
        const loop = async ()=>{
          const base = 220, intervals = [0,3,7,10];
          for (const i of intervals){ this._note(base*Math.pow(2,i/12), 8, 0.10); }
          const noise = this.ctx.createBuffer(1, this.ctx.sampleRate*8, this.ctx.sampleRate);
          const ch = noise.getChannelData(0); for (let i=0;i<ch.length;i++){ ch[i] = (Math.random()*2-1) * 0.05; }
          const src = this.ctx.createBufferSource(); src.buffer = noise;
          const nf = this.ctx.createBiquadFilter(); nf.type='lowpass'; nf.frequency.value=800;
          const g = this.ctx.createGain(); g.gain.value = 0.05; src.connect(nf); nf.connect(g); g.connect(this.master);
          src.start(); src.stop(this.ctx.currentTime+8);
          await new Promise(r=>setTimeout(r, 8500));
          this.loopHandle = requestAnimationFrame(loop);
        };
        loop();
      }
      _note(freq, dur=2, gain=0.10){
        const t = this.ctx.currentTime;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'sine'; o.frequency.value = freq;
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(gain, t+0.1);
        g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
        o.connect(g); g.connect(this.master); o.start(); o.stop(t+dur);
      }
    }
    async function ensureAudio(){
      if (!musicEngine) musicEngine = new Music();
      try{ if (cons.tts.checked) await musicEngine.start(); }catch{}
      if (musicEngine.ctx.state !== 'running'){ hint.style.display='flex'; }
      ['pointerdown','keydown','touchstart'].forEach(ev=>{
        window.addEventListener(ev, async ()=>{
          try{
            if (musicEngine?.ctx?.state === 'suspended') await musicEngine.ctx.resume();
            if (musicEngine && !musicEngine.loopHandle) await musicEngine.start();
            hint.style.display='none';
          }catch{}
        }, {once:false, passive:true});
      });
    }

    // ===== Emotion AI (MediaPipe) =====
    const video = document.getElementById('video');
    let faceLandmarker = null, running=false;
    async function initFaceAI(){
      const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest');
      const {FaceLandmarker, FilesetResolver} = vision;
      const resolver = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm');
      faceLandmarker = await FaceLandmarker.createFromOptions(resolver, {
        baseOptions: { modelAssetPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm/face_landmarker.task' },
        runningMode: 'VIDEO', numFaces: 1, outputFaceBlendshapes: false
      });
    }
    async function startCamera(){
      const stream = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
      video.srcObject = stream; await video.play();
    }
    function classifyEmotion(landmarks){
      const L = i=>landmarks[i], d=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
      const w = d(L(61),L(291))/ (d(L(33),L(263))||1);
      const o = d(L(13),L(14))/ (d(L(33),L(263))||1);
      const browLift = (L(1).y - ((L(70).y+L(300).y)/2));
      if (o>0.35) return 'surpresa';
      if (w>0.52 && o<0.28) return 'alegria';
      if (w<0.40 && o<0.22 && browLift<0.02) return 'raiva';
      if (w<0.44 && o<0.20 && browLift>0.04) return 'tristeza';
      return 'neutro';
    }

    // ===== Multilingual oracle =====
    const voiceSel = document.getElementById('voiceSel');
    const langSel = document.getElementById('langSel');
    const personaSel = document.getElementById('personaSel');
    const ancientMix = document.getElementById('ancientMix');
    const ttsMode = document.getElementById('ttsMode');
    const sttToggle = document.getElementById('sttToggle');

    let voices = [];
    function refreshVoices(){
      voices = speechSynthesis.getVoices();
      voiceSel.innerHTML = '';
      voices.forEach((v,i)=>{
        const opt = document.createElement('option'); opt.value = i; opt.textContent = `${v.name} — ${v.lang}`; voiceSel.appendChild(opt);
      });
      langSel.innerHTML = '';
      const seen = new Set();
      voices.forEach(v=>{ const k = v.lang; if (seen.has(k)) return; seen.add(k);
        const opt = document.createElement('option'); opt.value = k; opt.textContent = k; langSel.appendChild(opt);
      });
      if (!seen.size){ ['pt-PT','pt-BR','en-US','es-ES','fr-FR','de-DE','it-IT'].forEach(k=>{ const o=document.createElement('option'); o.value=k; o.textContent=k; langSel.appendChild(o); }); }
      const nav = navigator.language || 'en-US';
      for (const opt of langSel.options){ if (opt.value.toLowerCase().startsWith(nav.toLowerCase().slice(0,2))) { opt.selected=true; break; } }
    }
    refreshVoices();
    if (!speechSynthesis.getVoices().length) speechSynthesis.onvoiceschanged = refreshVoices;

    function pickVoice(langTag, persona='auto'){
      const list = voices.filter(v=> v.lang.toLowerCase().startsWith((langTag||'en').toLowerCase().slice(0,2)));
      let chosen = list[0] || voices[0];
      const nm = (v)=> (v?.name||'').toLowerCase();
      if (persona==='woman'){ chosen = list.find(v=> /female|mulher|sofia|maria|victoria|emma/i.test(nm(v))) || chosen; }
      else if (persona==='man'){ chosen = list.find(v=> /male|homem|joao|paulo|thomas|daniel|david/i.test(nm(v))) || chosen; }
      else if (persona==='child'){ chosen = list.find(v=> /child|kid|crianca|junior|young/i.test(nm(v))) || chosen; }
      return chosen;
    }

    function speakWebSpeech(text, langTag, persona){
      setCaption(text);
      try{
        const u = new SpeechSynthesisUtterance(text);
        u.lang = langTag || (navigator.language || 'en-US');
        const v = (voiceSel.value ? voices[parseInt(voiceSel.value,10)] : pickVoice(u.lang, persona));
        if (v) u.voice = v;
        if (persona==='woman'){ u.pitch = 1.15; u.rate = 0.98; }
        else if (persona==='man'){ u.pitch = 0.9; u.rate = 0.98; }
        else if (persona==='child'){ u.pitch = 1.35; u.rate = 1.02; }
        else { u.pitch = 1.0; u.rate = 0.98; }
        speechSynthesis.cancel(); speechSynthesis.speak(u);
      }catch(e){ console.warn('TTS error', e); }
    }

    async function speakNeural(text, langTag, persona){
      setCaption(text);
      try{
        const res = await fetch('/api/tts', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ text, lang: langTag || (navigator.language||'en-US'), persona })
        });
        if (!res.ok) throw new Error('TTS server error');
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const a = new Audio(); a.src = url; a.play().catch(()=>{});
        a.onended = ()=> URL.revokeObjectURL(url);
      }catch(e){
        console.warn('Neural TTS fetch failed, falling back to WebSpeech', e);
        speakWebSpeech(text, langTag, persona);
      }
    }

    function speak(text, langTag, persona){
      if (!cons.tts.checked) return;
      if (ttsMode.value === 'server') return speakNeural(text, langTag, persona);
      return speakWebSpeech(text, langTag, persona);
    }

    const ANCIENT = {
      latin: ["Lux in tenebris lucet.", "Amor vincit omnia.", "Respira, viator: iter te docet."],
      greek: ["Γνῶθι σεαυτόν.", "Πάντα ῥεῖ — ῥεῖς καὶ σύ.", "Ἡσυχία φωνὴ ψυχῆς."],
      sanskrit: ["शान्तिः शान्तिः शान्तिः", "अहं प्रेम अस्मि।", "धीरे धीरे—प्रत्येक श्वास में प्रकाश।"],
      hebrew: ["שלום עליכם", "אור קטן דוחה הרבה מן החושך", "נשום — והדרך תיפתח"]
    };
    const ORACLE = {
      'pt': ["Respira: em ti habita o templo do universo.", "Pede um sinal suave — as respostas amam portas discretas.", "A coragem nasce de passos pequenos e fiéis."],
      'en': ["Breathe: the temple of the universe lives within you.", "Ask for a gentle sign; answers love subtle doors.", "Courage grows from small faithful steps."],
      'es': ["Respira: el templo del universo habita en ti.", "Pide una señal suave; las respuestas aman puertas sutiles.", "El valor crece desde pasos pequeños y fieles."],
      'fr': ["Respire : le temple de l’univers vit en toi.", "Demande un signe doux ; les réponses aiment les portes subtiles.", "Le courage naît de petits pas fidèles."],
      'de': ["Atme: Der Tempel des Universums wohnt in dir.", "Bitte um ein leises Zeichen; Antworten lieben subtile Türen.", "Mut wächst aus kleinen, treuen Schritten."],
      'it': ["Respira: il tempio dell’universo vive in te.", "Chiedi un segno lieve; le risposte amano le porte sottili.", "Il coraggio nasce da piccoli passi fedeli."]
    };
    function langKey(tag){ const t=(tag||'').toLowerCase(); if (t.startsWith('pt')) return 'pt'; if (t.startsWith('en')) return 'en'; if (t.startsWith('es')) return 'es'; if (t.startsWith('fr')) return 'fr'; if (t.startsWith('de')) return 'de'; if (t.startsWith('it')) return 'it'; return 'en'; }
    function randomOf(arr){ return arr[(Math.random()*arr.length)|0]; }

    // STT (optional, only if consent and supported)
    let rec = null;
    function startSTT(){
      if (!cons.mic.checked) return;
      if (!('webkitSpeechRecognition' in window)){ console.warn('STT not available'); return; }
      const lang = (langSel.value || navigator.language || 'en-US');
      const R = new webkitSpeechRecognition();
      R.continuous = true; R.interimResults = true; R.lang = lang;
      R.onresult = (ev)=>{
        let finalTxt = ""; 
        for (let i=ev.resultIndex;i<ev.results.length;i++){ const r = ev.results[i]; if (r.isFinal) finalTxt += r[0].transcript; }
        if (finalTxt){
          setCaption(finalTxt.trim());
          speak(randomOf(ORACLE[langKey(lang)]||ORACLE['en']), lang, personaSel.value);
        }
      };
      R.onerror = ()=>{}; R.onend = ()=>{ if (document.getElementById('sttToggle').checked) R.start(); };
      R.start(); rec = R;
    }

    // Emotion loop
    async function loopFace(){
      if (!running || !faceLandmarker) return;
      const res = faceLandmarker.detectForVideo(video, performance.now());
      if (res?.faceLandmarks?.length){
        const emo = classifyEmotion(res.faceLandmarks[0]);
        if (emo==='alegria'){ particleColor='#ffd166'; bgLeft='#0f1a10'; bgRight='#1c2a1d'; SCATTER=3.2; }
        else if (emo==='surpresa'){ particleColor='#f6f1d1'; bgLeft='#100f1a'; bgRight='#221d2a'; SCATTER=4.0; }
        else if (emo==='tristeza'){ particleColor='#cde2ff'; bgLeft='#0d121a'; bgRight='#121a24'; SCATTER=2.0; }
        else if (emo==='raiva'){ particleColor='#ffd1d1'; bgLeft='#1a0d0d'; bgRight='#241212'; SCATTER=3.6; }
        else { particleColor='#ffffff'; bgLeft='#111111'; bgRight='#e9e9e9'; SCATTER=2.6; }
        init();
        if (Math.random()<0.1){
          const k = langKey(langSel.value || navigator.language);
          if (document.getElementById('ancientMix').checked && Math.random()<0.35){
            const pool=[...ANCIENT.latin, ...ANCIENT.greek, ...ANCIENT.sanskrit, ...ANCIENT.hebrew];
            speak(randomOf(pool), (k==='pt'?'pt-PT':'en-US'), personaSel.value);
          }else{
            speak(randomOf(ORACLE[k]||ORACLE['en']), langSel.value || navigator.language, personaSel.value);
          }
        }
      }
      requestAnimationFrame(loopFace);
    }

    // Geolocation (optional, consented, user-facing only)
    async function askGeo(){
      if (!cons.geo.checked) return;
      if (!('geolocation' in navigator)) return;
      try{
        const pos = await new Promise((res,rej)=> navigator.geolocation.getCurrentPosition(res, rej, {enableHighAccuracy:false, timeout:10000, maximumAge:60000}));
        const {latitude, longitude} = pos.coords;
        setCaption(`Local aproximado (consentido): ${latitude.toFixed(3)}, ${longitude.toFixed(3)}`);
      }catch{ /* user denied or failed */ }
    }

    // Recording (canvas + music) — no TTS capture
    let recorder=null, recChunks=[], recUrl=null;
    async function autoRecord(seconds=120){
      if (!cons.tts.checked) return; // keep simple: record when audio engine is on
      try{
        const canvasStream = canvas.captureStream(30);
        const mixed = new MediaStream();
        const vtrack = canvasStream.getVideoTracks()[0]; if (vtrack) mixed.addTrack(vtrack);
        if (!musicEngine) musicEngine = new Music();
        await musicEngine.start();
        const audioStream = musicEngine.getStream();
        audioStream.getAudioTracks().forEach(t=> mixed.addTrack(t));
        let opts = { mimeType: 'video/webm;codecs=vp9,opus' };
        if (!MediaRecorder.isTypeSupported(opts.mimeType)) opts = { mimeType: 'video/webm;codecs=vp8,opus' };
        if (!MediaRecorder.isTypeSupported(opts.mimeType)) opts = { mimeType: 'video/webm' };
        recorder = new MediaRecorder(mixed, opts);
        recChunks = [];
        recorder.ondataavailable = e => { if(e.data && e.data.size) recChunks.push(e.data); };
        recorder.onstop = ()=>{
          const blob = new Blob(recChunks, {type: 'video/webm'});
          recUrl && URL.revokeObjectURL(recUrl); recUrl = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = recUrl; a.download = 'divine-oracle-neural.webm';
          document.body.appendChild(a); a.click(); a.remove();
          setCaption("Gravação concluída.");
        };
        recorder.start(); setCaption("A gravar a tua sessão…");
        setTimeout(()=>{ try{recorder.stop();}catch{} }, seconds*1000);
      }catch(e){ console.warn('Recording error', e); }
    }

    // Boot with consent
    async function boot(){
      try{
        await ensureAudio();
        if (cons.cam.checked){ await initFaceAI(); await startCamera(); running = true; loopFace(); }
        if (cons.mic.checked && document.getElementById('sttToggle').checked) startSTT();
        await askGeo();
        const lang = (navigator.language||'en-US');
        speak("Estou contigo. O que procuras hoje?", lang, 'auto');
        autoRecord(120);
      }catch(e){
        setCaption("Permite câmara/áudio para a experiência completa (ou desativa no consentimento).");
        console.error(e);
      }
    }

    // Autoplay hints
    async function ensureAudio(){
      if (!cons.tts.checked) return;
      if (!musicEngine) musicEngine = new Music();
      try{ await musicEngine.start(); }catch{}
      if (musicEngine.ctx.state !== 'running'){ hint.style.display='flex'; }
      ['pointerdown','keydown','touchstart'].forEach(ev=>{
        window.addEventListener(ev, async ()=>{
          try{
            if (musicEngine?.ctx?.state === 'suspended') await musicEngine.ctx.resume();
            if (musicEngine && !musicEngine.loopHandle) await musicEngine.start();
            hint.style.display='none';
          }catch{}
        }, {once:false, passive:true});
      });
    }
  </script>
</body>
</html>
