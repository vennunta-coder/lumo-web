<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>IMAGINATION — DIVINE ORACLE</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; background:#0e0e10; color:#e9f6f1; overflow:hidden; }
    canvas { display:block; }
    #overlay { position:fixed; inset:0; pointer-events:none; z-index:5; }
    /* Hidden UI; only captions */
    #caption {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 18px; z-index: 10; pointer-events: none;
      background: rgba(0,0,0,.45); color: #e7ffe7;
      font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding: 8px 10px; border-radius: 10px; max-width: 92vw; text-align:center;
      box-shadow: 0 8px 24px rgba(0,0,0,.28);
    }
    #hint { position: fixed; inset: 0; display:flex; align-items:center; justify-content:center; z-index: 11;
      font: 14px system-ui; color:#dfe; background: rgba(0,0,0,.55); text-align:center; padding: 20px }
    #hint .card{ background:#101919; border:1px solid #1d2b2b; border-radius: 14px; padding: 16px 18px; max-width: 520px }
    #hint small{ display:block; margin-top:6px; color:#a7c3c3 }
    /* Secret settings (press S to toggle) */
    #secret { position: fixed; right: 12px; top: 12px; z-index: 12; display:none;
      background:#0c1212cc; border:1px solid #1b2a2a; border-radius:12px; padding:10px 12px; font: 12px system-ui; }
    #secret label{ display:flex; gap:6px; align-items:center; margin:6px 0 }
    #secret input, #secret select { background:#080d0d; color:#dfe; border:1px solid #223; border-radius:8px; padding:4px 6px }
    #secret small{ color:#9dc }
  </style>
</head>
<body>
  <div id="hint">
    <div class="card">
      <div>Toque em qualquer lugar para ativar o áudio. A câmara pedirá permissão.</div>
      <small>Processamento local: nada sai do teu dispositivo • Pressiona <b>S</b> para abrir definições ocultas.</small>
    </div>
  </div>
  <div id="caption" role="status" aria-live="polite">A invocar o Oráculo…</div>

  <canvas id="c"></canvas>
  <canvas id="overlay"></canvas>
  <video id="video" playsinline autoplay muted style="display:none"></video>

  <!-- Secret panel (hidden) -->
  <div id="secret">
    <div><b>Definições secretas</b> (tecla S)</div>
    <label>Idioma: <select id="langSel"></select></label>
    <label>Persona: 
      <select id="personaSel">
        <option value="auto">auto</option>
        <option value="woman">mulher</option>
        <option value="man">homem</option>
        <option value="child">criança</option>
      </select>
    </label>
    <label>Voz TTS: <select id="voiceSel"></select></label>
    <label><input id="ancientMix" type="checkbox" checked> Misturar línguas antigas</label>
    <label><input id="sttToggle" type="checkbox" checked> Ouvir a tua voz (STT)</label>
    <small>Alguns navegadores pedem clique para áudio/TTS e não suportam STT.</small>
  </div>

  <script type="module">
    // ===== Immersive canvas (based on prior editions) =====
    const canvas = document.getElementById('c');
    const overlay = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const octx = overlay.getContext('2d');
    const caption = document.getElementById('caption');
    const hint = document.getElementById('hint');
    const secret = document.getElementById('secret');

    const WORD = "IMAGINATION";
    const PRESET = { dot:"#ffffff", left:"#111111", right:"#e9e9e9", scatter:2.6, font:"Montserrat", size: 120 };

    function setCaption(t){ caption.textContent = t; }
    function toggleSecret(){ secret.style.display = (secret.style.display==='none' || !secret.style.display)?'block':'none'; }

    let GAP = 4, SIZE = 2, RETURN_SPEED = 20, SCATTER = PRESET.scatter;
    let FONT = ()=> `bold ${PRESET.size}px ${PRESET.font}`;
    let particleColor = PRESET.dot, bgLeft = PRESET.left, bgRight = PRESET.right;
    const mouse = { x: -9999, y: -9999, radius: 90 };
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mouseleave', () => { mouse.x = -9999; mouse.y = -9999; });
    window.addEventListener('keydown', (e)=>{ if (e.key.toLowerCase()==='s') toggleSecret(); });

    function resize() {
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      for (const cvs of [canvas, overlay]) {
        cvs.width = innerWidth * dpr; cvs.height = innerHeight * dpr;
        cvs.style.width = innerWidth + 'px'; cvs.style.height = innerHeight + 'px';
        const ctx2d = cvs.getContext('2d'); ctx2d.setTransform(dpr,0,0,dpr,0,0);
      }
      init();
    }
    window.addEventListener('resize', resize);

    let particles = [];
    class Particle {
      constructor(x, y) {
        this.baseX = x; this.baseY = y; this.x = x; this.y = y;
        this.vx = 0; this.vy = 0; this.size = SIZE; this.alpha = 1; this.dead = false;
        this.density = Math.random()*40 + 10;
      }
      draw() {
        if (this.dead) return;
        ctx.globalAlpha = this.alpha; ctx.fillStyle = particleColor;
        ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1;
      }
      update() {
        if (this.dead) return;
        const dx = mouse.x - this.x, dy = mouse.y - this.y, dist = Math.hypot(dx, dy);
        if (dist < mouse.radius) {
          const force = (mouse.radius - dist) / mouse.radius;
          const dirX = dx / (dist || 1), dirY = dy / (dist || 1);
          this.x -= dirX * force * this.density; this.y -= dirY * force * this.density;
          this.vx -= dirX * SCATTER * Math.random(); this.vy -= dirY * SCATTER * Math.random();
        } else {
          if (this.x !== this.baseX) this.x -= (this.x - this.baseX) / RETURN_SPEED;
          if (this.y !== this.baseY) this.y -= (this.y - this.baseY) / RETURN_SPEED;
        }
        this.x += this.vx; this.y += this.vy; this.vx *= 0.92; this.vy *= 0.92;
      }
    }
    function bg(){
      const midX = innerWidth / 2;
      ctx.fillStyle = bgLeft; ctx.fillRect(0,0,midX,innerHeight);
      ctx.fillStyle = bgRight; ctx.fillRect(midX,0,innerWidth - midX, innerHeight);
    }
    function init() {
      ctx.clearRect(0,0,innerWidth,innerHeight);
      ctx.save(); ctx.font = FONT(); ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      bg(); ctx.fillStyle = '#fff'; ctx.shadowColor = 'rgba(0,0,0,.35)'; ctx.shadowBlur = 6;
      ctx.fillText(WORD, innerWidth/2, innerHeight/2); ctx.restore();
      const img = ctx.getImageData(0, 0, innerWidth, innerHeight).data;
      particles = [];
      for (let y = 0; y < innerHeight; y += GAP) {
        for (let x = 0; x < innerWidth; x += GAP) {
          const i = (y * innerWidth + x) * 4;
          if (img[i+3] > 128) particles.push(new Particle(x,y));
        }
      }
    }
    function animate() {
      ctx.clearRect(0,0,innerWidth,innerHeight);
      bg();
      const grad = ctx.createLinearGradient(innerWidth*0.55,0,innerWidth,0);
      grad.addColorStop(0,'rgba(255,255,255,0)'); grad.addColorStop(1,'rgba(255,255,255,0.08)');
      ctx.fillStyle = grad; ctx.fillRect(innerWidth*0.55,0,innerWidth*0.45,innerHeight);
      for (let p of particles) { p.size = SIZE; p.update(); p.draw(); }
      requestAnimationFrame(animate);
    }
    function start() { resize(); animate(); }
    start();

    // ===== Music (ambient loop) =====
    let musicEngine = null;
    class Music {
      constructor(){
        this.ctx = new (window.AudioContext||window.webkitAudioContext)();
        this.master = this.ctx.createGain(); this.master.gain.value = 0.26; this.master.connect(this.ctx.destination);
        this.dest = this.ctx.createMediaStreamDestination(); this.master.connect(this.dest);
        this.loopHandle = null;
      }
      getStream(){ return this.dest.stream; }
      async start(){
        if (this.ctx.state === 'suspended') await this.ctx.resume();
        if (this.loopHandle) return;
        const loop = async ()=>{
          const base = 220, intervals = [0,3,7,10];
          for (const i of intervals){ this._note(base*Math.pow(2,i/12), 8, 0.10); }
          const noise = this.ctx.createBuffer(1, this.ctx.sampleRate*8, this.ctx.sampleRate);
          const ch = noise.getChannelData(0); for (let i=0;i<ch.length;i++){ ch[i] = (Math.random()*2-1) * 0.05; }
          const src = this.ctx.createBufferSource(); src.buffer = noise;
          const nf = this.ctx.createBiquadFilter(); nf.type='lowpass'; nf.frequency.value=800;
          const g = this.ctx.createGain(); g.gain.value = 0.05; src.connect(nf); nf.connect(g); g.connect(this.master);
          src.start(); src.stop(this.ctx.currentTime+8);
          await new Promise(r=>setTimeout(r, 8500));
          this.loopHandle = requestAnimationFrame(loop);
        };
        loop();
      }
      _note(freq, dur=2, gain=0.10){
        const t = this.ctx.currentTime;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'sine'; o.frequency.value = freq;
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(gain, t+0.1);
        g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
        o.connect(g); g.connect(this.master); o.start(); o.stop(t+dur);
      }
    }
    async function ensureAudio(){
      if (!musicEngine) musicEngine = new Music();
      try{ await musicEngine.start(); }catch{}
      if (musicEngine.ctx.state !== 'running'){ hint.style.display='flex'; }
      ['pointerdown','keydown','touchstart'].forEach(ev=>{
        window.addEventListener(ev, async ()=>{
          try{
            if (musicEngine?.ctx?.state === 'suspended') await musicEngine.ctx.resume();
            if (musicEngine && !musicEngine.loopHandle) await musicEngine.start();
            hint.style.display='none';
          }catch{}
        }, {once:false, passive:true});
      });
    }

    // ===== Emotion AI (MediaPipe) =====
    const video = document.getElementById('video');
    let faceLandmarker = null, running=false;
    async function initFaceAI(){
      const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest');
      const {FaceLandmarker, FilesetResolver} = vision;
      const resolver = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm');
      faceLandmarker = await FaceLandmarker.createFromOptions(resolver, {
        baseOptions: { modelAssetPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm/face_landmarker.task' },
        runningMode: 'VIDEO', numFaces: 1, outputFaceBlendshapes: false
      });
    }
    async function startCamera(){
      const stream = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
      video.srcObject = stream; await video.play();
    }
    function classifyEmotion(landmarks){
      const L = i=>landmarks[i], d=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
      const w = d(L(61),L(291))/ (d(L(33),L(263))||1);
      const o = d(L(13),L(14))/ (d(L(33),L(263))||1);
      const browLift = (L(1).y - ((L(70).y+L(300).y)/2));
      if (o>0.35) return 'surpresa';
      if (w>0.52 && o<0.28) return 'alegria';
      if (w<0.40 && o<0.22 && browLift<0.02) return 'raiva';
      if (w<0.44 && o<0.20 && browLift>0.04) return 'tristeza';
      return 'neutro';
    }

    // ===== Multilingual Divine Oracle =====
    const LANGS = [
      'pt-PT','pt-BR','en-US','es-ES','fr-FR','de-DE','it-IT','ru-RU','ja-JP','zh-CN','hi-IN','ar-SA'
    ];
    const ANCIENT = {
      latin: ["Lux in tenebris lucet.", "Amor vincit omnia.", "Respira, viator: iter te docet."],
      greek: ["Γνῶθι σεαυτόν.", "Πάντα ῥεῖ — ῥεῖς καὶ σύ.", "Ἡσυχία φωνὴ ψυχῆς."],
      sanskrit: ["शान्तिः शान्तिः शान्तिः", "अहं प्रेम अस्मि।", "धीरे धीरे—प्रत्येक श्वास में प्रकाश।"],
      hebrew: ["שלום עליכם", "אור קטן דוחה הרבה מן החושך", "נשום — והדרך תיפתח"]
    };
    const ORACLE = {
      'pt': [
        "Respira: em ti habita o templo do universo.",
        "Se precisares, pede um pequeno sinal — a resposta pode ser suave.",
        "A coragem nasce de passos pequenos e fiéis."
      ],
      'en': [
        "Breathe: the temple of the universe lives within you.",
        "Ask for a gentle sign; answers love subtle doors.",
        "Courage grows from small faithful steps."
      ],
      'es': [
        "Respira: el templo del universo habita en ti.",
        "Si lo necesitas, pide una señal suave — la respuesta puede ser discreta.",
        "El valor crece desde pasos pequeños y fieles."
      ],
      'fr': [
        "Respire : le temple de l’univers vit en toi.",
        "Demande un signe doux ; les réponses aiment les portes subtiles.",
        "Le courage naît de petits pas fidèles."
      ],
      'de': [
        "Atme: Der Tempel des Universums wohnt in dir.",
        "Bitte um ein leises Zeichen; Antworten lieben subtile Türen.",
        "Mut wächst aus kleinen, treuen Schritten."
      ],
      'it': [
        "Respira: il tempio dell’universo vive in te.",
        "Chiedi un segno lieve; le risposte amano le porte sottili.",
        "Il coraggio nasce da piccoli passi fedeli."
      ]
    };
    function langKey(tag){
      const t = (tag||'').toLowerCase();
      if (t.startsWith('pt')) return 'pt';
      if (t.startsWith('en')) return 'en';
      if (t.startsWith('es')) return 'es';
      if (t.startsWith('fr')) return 'fr';
      if (t.startsWith('de')) return 'de';
      if (t.startsWith('it')) return 'it';
      return 'en';
    }

    // TTS voice selection
    const voiceSel = document.getElementById('voiceSel');
    const langSel = document.getElementById('langSel');
    const personaSel = document.getElementById('personaSel');
    const ancientMix = document.getElementById('ancientMix');
    const sttToggle = document.getElementById('sttToggle');

    let voices = [];
    function refreshVoices(){
      voices = speechSynthesis.getVoices();
      voiceSel.innerHTML = '';
      voices.forEach((v,i)=>{
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = `${v.name} — ${v.lang}`;
        voiceSel.appendChild(opt);
      });
      // fill langs
      langSel.innerHTML = '';
      const seen = new Set();
      voices.forEach(v=>{
        const k = v.lang; if (seen.has(k)) return; seen.add(k);
        const opt = document.createElement('option'); opt.value = k; opt.textContent = k;
        langSel.appendChild(opt);
      });
      if (!seen.size){
        LANGS.forEach(k=>{
          const opt = document.createElement('option'); opt.value = k; opt.textContent = k;
          langSel.appendChild(opt);
        });
      }
      // select navigator language if exists
      const nav = navigator.language || 'en-US';
      for (const opt of langSel.options){ if (opt.value.toLowerCase().startsWith(nav.toLowerCase().slice(0,2))) { opt.selected=true; break; } }
    }
    refreshVoices();
    if (!speechSynthesis.getVoices().length) speechSynthesis.onvoiceschanged = refreshVoices;

    function pickVoice(langTag, persona='auto'){
      const list = voices.filter(v=> v.lang.toLowerCase().startsWith((langTag||'en').toLowerCase().slice(0,2)));
      let chosen = list[0] || voices[0];
      // persona heuristics by name
      const nm = (v)=> (v?.name||'').toLowerCase();
      if (persona==='woman'){
        chosen = list.find(v=> /female|mulher|sara|samantha|paula|sofia|lúcia|emma|victoria|maria/i.test(nm(v))) || chosen;
      } else if (persona==='man'){
        chosen = list.find(v=> /male|homem|joão|joao|paulo|diego|daniel|thomas|fred|david|james/i.test(nm(v))) || chosen;
      } else if (persona==='child'){
        chosen = list.find(v=> /child|kid|crianca|crianca|junior|young/i.test(nm(v))) || chosen;
      }
      return chosen;
    }

    function speak(text, langTag, persona='auto'){
      setCaption(text);
      try{
        const u = new SpeechSynthesisUtterance(text);
        u.lang = langTag || (navigator.language || 'en-US');
        const v = (voiceSel.value ? voices[parseInt(voiceSel.value,10)] : pickVoice(u.lang, persona));
        if (v) u.voice = v;
        // adjust pitch/rate by persona if needed
        if (persona==='woman'){ u.pitch = 1.15; u.rate = 0.98; }
        else if (persona==='man'){ u.pitch = 0.9; u.rate = 0.98; }
        else if (persona==='child'){ u.pitch = 1.35; u.rate = 1.02; }
        else { u.pitch = 1.0; u.rate = 0.98; }
        speechSynthesis.cancel();
        speechSynthesis.speak(u);
      }catch(e){ console.warn('TTS error', e); }
    }

    function randomOf(arr){ return arr[(Math.random()*arr.length)|0]; }

    // Emotion-adaptive colors + oracle lines
    function themeForEmotion(e){
      if (e==='alegria'){ particleColor='#ffd166'; bgLeft='#0f1a10'; bgRight='#1c2a1d'; SCATTER=3.2; }
      else if (e==='surpresa'){ particleColor='#f6f1d1'; bgLeft='#100f1a'; bgRight='#221d2a'; SCATTER=4.0; }
      else if (e==='tristeza'){ particleColor='#cde2ff'; bgLeft='#0d121a'; bgRight='#121a24'; SCATTER=2.0; }
      else if (e==='raiva'){ particleColor='#ffd1d1'; bgLeft='#1a0d0d'; bgRight='#241212'; SCATTER=3.6; }
      else { particleColor='#ffffff'; bgLeft='#111111'; bgRight='#e9e9e9'; SCATTER=2.6; }
      init();
    }

    function respondOracle(e){
      const k = langKey(langSel.value || navigator.language);
      const line = (ORACLE[k]||ORACLE['en']||[]);
      const persona = personaSel.value || 'auto';
      // sometimes mix ancient
      if (ancientMix.checked && Math.random() < 0.35){
        const pools = [].concat(ANCIENT.latin, ANCIENT.greek, ANCIENT.sanskrit, ANCIENT.hebrew);
        const chant = randomOf(pools);
        speak(chant, (k==='pt'?'pt-PT':'en-US'), persona);
      } else {
        const l = line.length? randomOf(line): "I am with you — breathe.";
        speak(l, langSel.value || navigator.language, persona);
      }
    }

    // STT (optional)
    let rec = null;
    function startSTT(){
      if (!('webkitSpeechRecognition' in window)){ console.warn('STT not available'); return; }
      const lang = (langSel.value || navigator.language || 'en-US');
      const R = new webkitSpeechRecognition();
      R.continuous = true; R.interimResults = true; R.lang = lang;
      R.onresult = (ev)=>{
        let finalTxt = ""; 
        for (let i=ev.resultIndex;i<ev.results.length;i++){
          const r = ev.results[i];
          if (r.isFinal) finalTxt += r[0].transcript;
        }
        if (finalTxt){
          setCaption(finalTxt.trim());
          const text = finalTxt.toLowerCase();
          // simple intent
          if (/(calma|paz|tranq|calm|peace)/i.test(text)) speak(randomOf(ORACLE[langKey(lang)]||ORACLE['en']), lang, personaSel.value);
          else if (/(força|coragem|strength|courage)/i.test(text)) speak(randomOf(ORACLE[langKey(lang)]||ORACLE['en']), lang, personaSel.value);
          else speak(randomOf(ORACLE[langKey(lang)]||ORACLE['en']), lang, personaSel.value);
        }
      };
      R.onerror = ()=>{}; R.onend = ()=>{ if (sttToggle.checked) R.start(); };
      R.start(); rec = R;
    }

    // Loop
    async function loop(){
      if (!running || !faceLandmarker) return requestAnimationFrame(loop);
      const res = faceLandmarker.detectForVideo(video, performance.now());
      if (res?.faceLandmarks?.length){
        const emo = classifyEmotion(res.faceLandmarks[0]);
        themeForEmotion(emo);
        if (Math.random()<0.1) respondOracle(emo);
      }
      requestAnimationFrame(loop);
    }

    // Recording (canvas + music). TTS is NOT captured by browser.
    let recorder=null, recChunks=[], recUrl=null;
    async function autoRecord(seconds=120){
      try{
        const canvasStream = canvas.captureStream(30);
        const mixed = new MediaStream();
        const vtrack = canvasStream.getVideoTracks()[0]; if (vtrack) mixed.addTrack(vtrack);
        if (!musicEngine) musicEngine = new Music();
        await musicEngine.start();
        const audioStream = musicEngine.getStream();
        audioStream.getAudioTracks().forEach(t=> mixed.addTrack(t));
        let opts = { mimeType: 'video/webm;codecs=vp9,opus' };
        if (!MediaRecorder.isTypeSupported(opts.mimeType)) opts = { mimeType: 'video/webm;codecs=vp8,opus' };
        if (!MediaRecorder.isTypeSupported(opts.mimeType)) opts = { mimeType: 'video/webm' };
        recorder = new MediaRecorder(mixed, opts);
        recChunks = [];
        recorder.ondataavailable = e => { if(e.data && e.data.size) recChunks.push(e.data); };
        recorder.onstop = ()=>{
          const blob = new Blob(recChunks, {type: 'video/webm'});
          recUrl && URL.revokeObjectURL(recUrl); recUrl = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = recUrl; a.download = 'divine-oracle.webm';
          document.body.appendChild(a); a.click(); a.remove();
          setCaption("Gravação concluída.");
        };
        recorder.start(); setCaption("A gravar a tua sessão…");
        setTimeout(()=>{ try{recorder.stop();}catch{} }, seconds*1000);
      }catch(e){ console.warn('Recording error', e); }
    }

    // Boot
    async function boot(){
      try{
        await ensureAudio();
        await initFaceAI();
        await startCamera();
        running = true;
        speak("Estou contigo. O que procuras hoje?", (navigator.language||'en-US'), 'auto');
        if (sttToggle.checked) startSTT();
        loop();
        autoRecord(120);
      }catch(e){
        setCaption("Permite câmara/áudio para a experiência completa.");
        console.error(e);
      }
    }
    boot();

  </script>
</body>
</html>
