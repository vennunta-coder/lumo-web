<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>IMAGINATION — PRO STUDIO AUTO VOICE</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; background:#111; overflow:hidden; }
    /* No control panel; only subtle captions for feedback */
    #caption {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 18px; z-index: 10; pointer-events: none;
      background: rgba(0,0,0,.45); color: #e7ffe7;
      font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding: 8px 10px; border-radius: 10px; max-width: 90vw; text-align:center;
      box-shadow: 0 8px 24px rgba(0,0,0,.28);
    }
    #hint { position: fixed; inset: 0; display:none; align-items:center; justify-content:center; z-index: 11;
      font: 14px system-ui; color:#dfe; background: rgba(0,0,0,.55); text-align:center; padding: 20px }
    #hint .card{ background:#101919; border:1px solid #1d2b2b; border-radius: 14px; padding: 16px 18px; max-width: 520px }
    #hint small{ display:block; margin-top:6px; color:#a7c3c3 }
    canvas { display:block; }
    #overlay { position:fixed; inset:0; pointer-events:none; z-index:5; }
  </style>
</head>
<body>
  <div id="hint">
    <div class="card">
      <div>Toque em qualquer lugar para ativar o áudio. A câmara pedirá permissão.</div>
      <small>Processamento local: nada sai do teu dispositivo.</small>
    </div>
  </div>
  <div id="caption" role="status" aria-live="polite">A iniciar experiência…</div>
  <canvas id="c"></canvas>
  <canvas id="overlay"></canvas>
  <video id="video" playsinline autoplay muted style="display:none"></video>

  <script type="module">
    // ===== Minimal immersive engine (Sereno preset) =====
    const SERENO = { dot:"#ffffff", left:"#111111", right:"#e9e9e9", scatter:2.6, font:"Montserrat" };
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const octx = overlay.getContext('2d');
    const caption = document.getElementById('caption');
    const hint = document.getElementById('hint');

    function setCaption(t){ caption.textContent = t; }
    const WORD = "IMAGINATION";

    let GAP = 4, SIZE = 2, RETURN_SPEED = 20, SCATTER = SERENO.scatter;
    let FONT = ()=> `bold 120px ${SERENO.font}`;
    let particleColor = SERENO.dot, bgLeft = SERENO.left, bgRight = SERENO.right;

    function resize() {
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      for (const cvs of [canvas, overlay]) {
        cvs.width = innerWidth * dpr;
        cvs.height = innerHeight * dpr;
        cvs.style.width = innerWidth + 'px';
        cvs.style.height = innerHeight + 'px';
        const ctx2d = cvs.getContext('2d');
        ctx2d.setTransform(dpr,0,0,dpr,0,0);
      }
      init();
    }
    window.addEventListener('resize', resize);

    const mouse = { x: -9999, y: -9999, radius: 90 };
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mouseleave', () => { mouse.x = -9999; mouse.y = -9999; });

    let particles = [];
    class Particle {
      constructor(x, y, color='white') {
        this.baseX = x; this.baseY = y;
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.size = SIZE; this.color = color; this.alpha = 1; this.dead = false;
        this.density = Math.random()*40 + 10;
      }
      draw() {
        if (this.dead) return;
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
      }
      update(permanent=false) {
        if (this.dead) return;
        const dx = mouse.x - this.x, dy = mouse.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < mouse.radius) {
          const force = (mouse.radius - dist) / mouse.radius;
          const dirX = dx / (dist || 1), dirY = dy / (dist || 1);
          this.x -= dirX * force * this.density;
          this.y -= dirY * force * this.density;
          this.vx -= dirX * SCATTER * Math.random();
          this.vy -= dirY * SCATTER * Math.random();
        } else {
          if (this.x !== this.baseX) this.x -= (this.x - this.baseX) / RETURN_SPEED;
          if (this.y !== this.baseY) this.y -= (this.y - this.baseY) / RETURN_SPEED;
        }
        this.x += this.vx; this.y += this.vy;
        this.vx *= 0.92; this.vy *= 0.92;
      }
    }

    function bg(){
      const midX = innerWidth / 2;
      ctx.fillStyle = bgLeft; ctx.fillRect(0,0,midX,innerHeight);
      ctx.fillStyle = bgRight; ctx.fillRect(midX,0,innerWidth - midX, innerHeight);
    }
    function init() {
      ctx.clearRect(0,0,innerWidth,innerHeight);
      ctx.save();
      ctx.font = FONT(); ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      bg();
      ctx.fillStyle = '#fff'; ctx.shadowColor = 'rgba(0,0,0,.35)'; ctx.shadowBlur = 6;
      ctx.fillText(WORD, innerWidth/2, innerHeight/2);
      ctx.restore();
      const img = ctx.getImageData(0, 0, innerWidth, innerHeight).data;
      particles = [];
      for (let y = 0; y < innerHeight; y += GAP) {
        for (let x = 0; x < innerWidth; x += GAP) {
          const i = (y * innerWidth + x) * 4;
          if (img[i+3] > 128) particles.push(new Particle(x,y,particleColor));
        }
      }
    }
    function animate() {
      ctx.clearRect(0,0,innerWidth,innerHeight);
      bg();
      const grad = ctx.createLinearGradient(innerWidth*0.55,0,innerWidth,0);
      grad.addColorStop(0,'rgba(255,255,255,0)');
      grad.addColorStop(1,'rgba(255,255,255,0.08)');
      ctx.fillStyle = grad; ctx.fillRect(innerWidth*0.55,0,innerWidth*0.45,innerHeight);
      for (let p of particles) { p.size = SIZE; p.color = particleColor; p.update(false); p.draw(); }
      requestAnimationFrame(animate);
    }

    function start() { resize(); animate(); }
    start();

    // ===== Music engine (ambient default) =====
    let musicEngine = null;
    class Music {
      constructor(){
        this.ctx = new (window.AudioContext||window.webkitAudioContext)();
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.25;
        this.master.connect(this.ctx.destination);
        this.recDest = this.ctx.createMediaStreamDestination();
        this.master.connect(this.recDest);
        this.mode = 'ambient';
        this.loopHandle = null;
      }
      getStream(){ return this.recDest.stream; }
      async start(){
        if (this.ctx.state === 'suspended') await this.ctx.resume();
        if (this.loopHandle) return;
        const loop = async ()=>{
          this.playAmbient();
          await new Promise(r=>setTimeout(r, 8500));
          this.loopHandle = requestAnimationFrame(loop);
        };
        loop();
      }
      stop(){ if (this.loopHandle){ cancelAnimationFrame(this.loopHandle); this.loopHandle = null; } }
      note(freq, dur=2, gain=0.10){
        const t = this.ctx.currentTime;
        const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
        o.type = 'sine'; o.frequency.value = freq;
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(gain, t+0.1);
        g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
        o.connect(g); g.connect(this.master); o.start(); o.stop(t+dur);
      }
      playAmbient(){
        const base = 220, intervals = [0,3,7,10];
        for (const i of intervals){ this.note(base*Math.pow(2,i/12), 8, 0.10); }
        const noise = this.ctx.createBuffer(1, this.ctx.sampleRate*8, this.ctx.sampleRate);
        const ch = noise.getChannelData(0);
        for (let i=0;i<ch.length;i++){ ch[i] = (Math.random()*2-1) * 0.05; }
        const src = this.ctx.createBufferSource(); src.buffer = noise;
        const nf = this.ctx.createBiquadFilter(); nf.type='lowpass'; nf.frequency.value=800;
        const g = this.ctx.createGain(); g.gain.value = 0.05;
        src.connect(nf); nf.connect(g); g.connect(this.master); src.start(); src.stop(this.ctx.currentTime+8);
      }
    }

    async function ensureAudio(){
      if (!musicEngine) musicEngine = new Music();
      try{ await musicEngine.start(); }
      catch{ /* will try again on user gesture */ }
      // show hint if autoplay likely blocked
      if (musicEngine.ctx.state !== 'running'){
        hint.style.display = 'flex';
      }
      ['pointerdown','keydown','touchstart'].forEach(ev=>{
        window.addEventListener(ev, async ()=>{
          try{
            if (musicEngine?.ctx?.state === 'suspended') await musicEngine.ctx.resume();
            if (musicEngine && !musicEngine.loopHandle) await musicEngine.start();
            hint.style.display='none';
          }catch{}
        }, {once:false, passive:true});
      });
    }

    // ===== Emotion AI (MediaPipe) =====
    const video = document.getElementById('video');
    let faceLandmarker = null, running=false, rafId=0;

    async function initFaceAI(){
      const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest');
      const {FaceLandmarker, FilesetResolver} = vision;
      const resolver = await FilesetResolver.forVisionTasks(
        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'
      );
      faceLandmarker = await FaceLandmarker.createFromOptions(resolver, {
        baseOptions: {
          modelAssetPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm/face_landmarker.task'
        },
        runningMode: 'VIDEO',
        numFaces: 1,
        outputFaceBlendshapes: false
      });
    }
    async function startCamera(){
      const stream = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
      video.srcObject = stream; await video.play();
    }
    function classifyEmotion(landmarks){
      const L = i=>landmarks[i], d=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
      const w = d(L(61),L(291))/ (d(L(33),L(263))||1);
      const o = d(L(13),L(14))/ (d(L(33),L(263))||1);
      const browLift = (L(1).y - ((L(70).y+L(300).y)/2));
      if (o>0.35) return 'surpresa';
      if (w>0.52 && o<0.28) return 'alegria';
      if (w<0.40 && o<0.22 && browLift<0.02) return 'raiva';
      if (w<0.44 && o<0.20 && browLift>0.04) return 'tristeza';
      return 'neutro';
    }
    function setThemeForEmotion(e){
      if (e==='alegria'){ particleColor='#ffd166'; bgLeft='#0f1a10'; bgRight='#1c2a1d'; SCATTER=3.2; speakDivine(randomOf(EMO.alegria), 1.0); }
      else if (e==='surpresa'){ particleColor='#f6f1d1'; bgLeft='#100f1a'; bgRight='#221d2a'; SCATTER=4.0; speakDivine(randomOf(EMO.surpresa), 1.0); }
      else if (e==='tristeza'){ particleColor='#cde2ff'; bgLeft='#0d121a'; bgRight='#121a24'; SCATTER=2.0; speakDivine(randomOf(EMO.tristeza), 0.95); }
      else if (e==='raiva'){ particleColor='#ffd1d1'; bgLeft='#1a0d0d'; bgRight='#241212'; SCATTER=3.6; speakDivine(randomOf(EMO.raiva), 0.95); }
      else { particleColor='#ffffff'; bgLeft='#111111'; bgRight='#e9e9e9'; SCATTER=2.6; if(Math.random()<0.15) speakDivine(randomOf(EMO.neutro), 0.98); }
      init();
    }

    // ===== "Divine" voice assistant (TTS + captions) =====
    const EMO = {
      alegria: [
        "A tua luz é um farol — mantém-na acesa. 🌞",
        "A alegria que nasce em ti faz florescer o mundo ao redor.",
        "Segue leve: o caminho abre quando o coração sorri."
      ],
      surpresa: [
        "O novo te visita: recebe-o com curiosidade e calma. ✨",
        "Onde há espanto, há sementes de descoberta.",
        "Respira; a vida revela mais a cada passo."
      ],
      tristeza: [
        "Sou contigo no silêncio — repousa e confia. 💛",
        "A noite também é colo: nela a alma aprende a renascer.",
        "Sente sem pressa; até a maré baixa conhece o abraço do mar."
      ],
      raiva: [
        "Canaliza o fogo para criar, não queimar. Forja a tua obra. 🔥",
        "Respira 4-6: inspira em 4, expira em 6 — deixa o corpo recordar a paz.",
        "O vigor que te move pode erguer pontes."
      ],
      neutro: [
        "Se precisares, pede um pequeno sinal — a resposta pode ser suave.",
        "No ritmo do agora, cada gesto é oração discreta.",
        "Estou aqui. Um passo de cada vez."
      ]
    };
    function randomOf(arr){ return arr[(Math.random()*arr.length)|0]; }
    function speakDivine(text, pitch=1.0){
      setCaption(text);
      try{
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'pt-PT'; u.rate = 0.98; u.pitch = pitch;
        // pick a PT voice if available
        const pick = (voices)=> voices.find(v=>/pt|portuguese/i.test(v.lang)) || voices[0];
        const assign = ()=>{ const v = pick(speechSynthesis.getVoices()); if (v) u.voice = v; speechSynthesis.speak(u); };
        if (speechSynthesis.getVoices().length) assign(); else speechSynthesis.onvoiceschanged = assign;
      }catch{}
    }

    // Periodic gentle guidance (every ~30s)
    setInterval(()=>{
      const pool = [].concat(EMO.neutro);
      if (Math.random()<0.3) pool.push(...EMO.alegria);
      if (Math.random()<0.2) pool.push(...EMO.surpresa);
      speakDivine(randomOf(pool), 1.0);
    }, 30000);

    // ===== Loop for face detection
    async function loopFace(){
      if (!running || !faceLandmarker) return;
      const ts = performance.now();
      const res = faceLandmarker.detectForVideo(video, ts);
      if (res?.faceLandmarks?.length){
        const emo = classifyEmotion(res.faceLandmarks[0]);
        setThemeForEmotion(emo);
      }
      requestAnimationFrame(loopFace);
    }

    // ===== Auto start everything (camera, AI, music, recording) =====
    async function boot(){
      try{
        await ensureAudio();
        setCaption("A iniciar câmara…");
        await initFaceAI();
        await startCamera();
        running = true;
        setCaption("A sentir-te. Respira.");
        loopFace();
        startAutoRecording(120); // seconds
      }catch(e){
        setCaption("Permite câmara/áudio para a experiência completa.");
        console.error(e);
      }
    }
    boot();

    // ===== Recording (canvas + music) with auto-stop & download =====
    let recorder = null, recChunks = [], recUrl = null;
    async function startAutoRecording(seconds=120){
      try{
        const fps = 30;
        const canvasStream = canvas.captureStream(fps);
        const mixed = new MediaStream();
        const vtrack = canvasStream.getVideoTracks()[0];
        if (vtrack) mixed.addTrack(vtrack);
        if (!musicEngine){ musicEngine = new Music(); await musicEngine.start(); }
        const audioStream = musicEngine.getStream();
        audioStream.getAudioTracks().forEach(t=> mixed.addTrack(t));
        let opts = { mimeType: 'video/webm;codecs=vp9,opus' };
        if (!MediaRecorder.isTypeSupported(opts.mimeType)) opts = { mimeType: 'video/webm;codecs=vp8,opus' };
        if (!MediaRecorder.isTypeSupported(opts.mimeType)) opts = { mimeType: 'video/webm' };
        recorder = new MediaRecorder(mixed, opts);
        recChunks = [];
        recorder.ondataavailable = e => { if(e.data && e.data.size) recChunks.push(e.data); };
        recorder.onstop = ()=>{
          const blob = new Blob(recChunks, {type: 'video/webm'});
          recUrl && URL.revokeObjectURL(recUrl);
          recUrl = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = recUrl; a.download = 'imagination-auto.webm';
          document.body.appendChild(a); a.click(); a.remove();
          setCaption("Gravação concluída. Ficheiro baixado.");
        };
        recorder.start();
        setCaption("A gravar a tua sessão…");
        setTimeout(()=>{ try{ recorder.stop(); }catch{} }, seconds*1000);
      }catch(e){
        console.error(e);
        setCaption("Não foi possível iniciar a gravação.");
      }
    }

    // Try to resume audio on any user gesture (if autoplay blocked)
    ['pointerdown','keydown','touchstart'].forEach(ev=>{
      window.addEventListener(ev, async ()=>{
        try{
          if (musicEngine?.ctx?.state === 'suspended') await musicEngine.ctx.resume();
        }catch{}
        hint.style.display='none';
      }, {passive:true});
    });
  </script>
</body>
</html>
