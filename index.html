<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>IMAGINATION â€” PRO STUDIO (WebM + Presets)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --panel-bg: rgba(0,0,0,.55);
      --panel-text:#eee;
      --accent:#5be37d;
      --danger:#ff5d5d;
      --muted:#b9c1c7;
    }
    html, body { height: 100%; margin: 0; background:#111; overflow:hidden; }
    #ui {
      position: fixed; top: 12px; left: 12px; z-index: 10;
      font: 13.5px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: var(--panel-text); background: var(--panel-bg);
      padding: 10px 12px; border-radius: 12px; backdrop-filter: blur(6px);
      max-width: min(88vw, 520px);
    }
    #ui h1 { margin:0 0 6px; font-size:16px; letter-spacing:.3px }
    #ui .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:6px 0}
    #ui label{ display:flex; align-items:center; gap:6px; cursor:pointer; user-select:none }
    #ui input[type="text"]{ flex:1; padding:6px 8px; border-radius:8px; border:1px solid #333; background:#0b0b0b; color:#ddd }
    #ui input[type="range"]{ width:120px }
    #ui input[type="color"]{ width:36px; height:28px; padding:0; border:0; background:transparent; }
    #ui select{ padding:6px 8px; border-radius:8px; border:1px solid #333; background:#0b0b0b; color:#ddd }
    #ui button {
      padding: 6px 10px; border: 0; border-radius: 8px; cursor: pointer; background:#1d1d1d; color:#eaeaea;
    }
    #ui .pill { padding:4px 8px; border-radius:999px; font-size:12px; }
    #ui .ok { background:#163e24; color:#89f5a8; }
    #ui .warn { background:#3e2a16; color:#f5c189; }
    #ui .err { background:#3e1616; color:#ff9b9b; }
    #emoPhrase { margin-top:6px; font-size:13px; color:#dfe; min-height:1.4em }
    #credit { position:fixed; right:12px; bottom:12px; color:#7a7a7a; font: 12px system-ui; z-index:10; background:rgba(0,0,0,.4); padding:6px 8px; border-radius:8px }
    canvas { display:block; }
    #overlay { position:fixed; inset:0; pointer-events:none; z-index:5; }
    .badge {
      position:fixed; top:12px; right:12px; z-index:9; padding:6px 10px; border-radius:999px;
      background:rgba(0,0,0,.45); color:#d6ffd6; font:12px system-ui; display:flex; align-items:center; gap:6px;
      transform: translateY(56px);
    }
  </style>
</head>
<body>
  <div id="ui">
    <h1>IMAGINATION â€” PRO STUDIO</h1>

    <div class="row">
      <input id="wordInput" type="text" value="IMAGINATION" />
      <button id="resetBtn">Reset</button>
      <label>Preset
        <select id="presetSelect">
          <option value="">â€”</option>
          <option value="Solar">Solar</option>
          <option value="Noite Fria">Noite Fria</option>
          <option value="Sereno">Sereno</option>
          <option value="Neon">Neon</option>
          <option value="Pastel">Pastel</option>
        </select>
      </label>
      <button id="applyPreset">Aplicar</button>
    </div>

    <div class="row">
      <label>Fonte
        <select id="fontSelect">
          <option value="Arial Black" selected>Arial Black</option>
          <option value="Impact">Impact</option>
          <option value="Montserrat">Montserrat</option>
          <option value="Verdana">Verdana</option>
        </select>
      </label>
      <label>Tamanho <input id="fontSize" type="range" min="60" max="220" value="120" /></label>
    </div>

    <div class="row">
      <label>PartÃ­culas <input id="gap" type="range" min="2" max="10" value="4" /></label>
      <label>Tamanho <input id="dotSize" type="range" min="1" max="5" value="2" /></label>
    </div>

    <div class="row">
      <label>Raio rato <input id="radius" type="range" min="40" max="200" value="90" /></label>
      <label>Retorno <input id="returnSpeed" type="range" min="5" max="50" value="20" /></label>
      <label>Scatter <input id="scatter" type="range" min="0.5" max="6" step="0.1" value="2.6" /></label>
    </div>

    <div class="row">
      <label>Cor partÃ­cula <input id="dotColor" type="color" value="#ffffff" /></label>
      <label>BG esquerda <input id="bgLeft" type="color" value="#111111" /></label>
      <label>BG direita <input id="bgRight" type="color" value="#e9e9e9" /></label>
      <label><input id="permanent" type="checkbox"> Permanente</label>
    </div>

    <div class="row" style="border-top:1px solid #2a2a2a; padding-top:8px; margin-top:8px">
      <strong>MÃºsica</strong>
      <button id="musicToggle">Tocar</button>
      <label>Vol <input id="vol" type="range" min="0" max="1" step="0.01" value="0.25" /></label>
      <label>Modo
        <select id="musicMode">
          <option value="ambient" selected>ambient</option>
          <option value="major">major</option>
          <option value="minor">minor</option>
          <option value="calm">calm</option>
        </select>
      </label>
      <input id="audioFile" type="file" accept="audio/*" />
    </div>

    <div class="row" style="border-top:1px solid #2a2a2a; padding-top:8px; margin-top:8px">
      <strong>GravaÃ§Ã£o</strong>
      <button id="recStart">Gravar WebM</button>
      <button id="recStop" disabled>Parar</button>
      <a id="recDownload" download="imagination.webm" style="display:none"><button>Baixar</button></a>
      <label>FPS <input id="recFps" type="range" min="15" max="60" value="30" /></label>
      <span id="recStatus" class="pill warn">parado</span>
    </div>
  </div>

  <div id="credit">Dica: a gravaÃ§Ã£o captura o canvas e a mÃºsica do app (nÃ£o inclui o overlay nem microfone).</div>
  <div class="badge" id="emotionBadge" style="display:none">ðŸ™‚ neutro</div>

  <canvas id="c"></canvas>
  <canvas id="overlay"></canvas>

  <script type="module">
    // ===== Canvas particles =====
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const octx = overlay.getContext('2d');
    const ui = {
      wordInput: document.getElementById('wordInput'),
      resetBtn: document.getElementById('resetBtn'),
      fontSelect: document.getElementById('fontSelect'),
      fontSize: document.getElementById('fontSize'),
      gap: document.getElementById('gap'),
      dotSize: document.getElementById('dotSize'),
      radius: document.getElementById('radius'),
      returnSpeed: document.getElementById('returnSpeed'),
      scatter: document.getElementById('scatter'),
      dotColor: document.getElementById('dotColor'),
      bgLeft: document.getElementById('bgLeft'),
      bgRight: document.getElementById('bgRight'),
      permanent: document.getElementById('permanent'),
      musicToggle: document.getElementById('musicToggle'),
      vol: document.getElementById('vol'),
      audioFile: document.getElementById('audioFile'),
      musicMode: document.getElementById('musicMode'),
      recStart: document.getElementById('recStart'),
      recStop: document.getElementById('recStop'),
      recDownload: document.getElementById('recDownload'),
      recFps: document.getElementById('recFps'),
      recStatus: document.getElementById('recStatus'),
      presetSelect: document.getElementById('presetSelect'),
      applyPreset: document.getElementById('applyPreset')
    };

    function resize() {
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      for (const cvs of [canvas, overlay]) {
        cvs.width = innerWidth * dpr;
        cvs.height = innerHeight * dpr;
        cvs.style.width = innerWidth + 'px';
        cvs.style.height = innerHeight + 'px';
        const ctx2d = cvs.getContext('2d');
        ctx2d.setTransform(dpr,0,0,dpr,0,0);
      }
      init();
    }
    window.addEventListener('resize', resize);

    const mouse = { x: -9999, y: -9999, radius: parseFloat(ui.radius.value) };
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mouseleave', () => { mouse.x = -9999; mouse.y = -9999; });

    let particles = [];
    let WORD = ui.wordInput.value;
    let FONT = () => `bold ${ui.fontSize.value}px ${ui.fontSelect.value}`;
    let GAP = parseInt(ui.gap.value,10);
    let SIZE = parseInt(ui.dotSize.value,10);
    let RETURN_SPEED = parseFloat(ui.returnSpeed.value);
    let SCATTER = parseFloat(ui.scatter.value);

    class Particle {
      constructor(x, y, color='white') {
        this.baseX = x; this.baseY = y;
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.size = SIZE;
        this.color = color;
        this.alpha = 1;
        this.dead = false;
        this.density = Math.random()*40 + 10;
      }
      draw() {
        if (this.dead) return;
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
      }
      update(permanent) {
        if (this.dead) return;
        const dx = mouse.x - this.x;
        const dy = mouse.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < mouse.radius) {
          const force = (mouse.radius - dist) / mouse.radius;
          const dirX = dx / (dist || 1);
          const dirY = dy / (dist || 1);
          this.x -= dirX * force * this.density;
          this.y -= dirY * force * this.density;
          this.vx -= dirX * SCATTER * Math.random();
          this.vy -= dirY * SCATTER * Math.random();
          if (ui.permanent.checked) {
            this.alpha = Math.max(0, this.alpha - 0.08);
            if (this.alpha <= 0.02) this.dead = true;
          }
        } else if (!ui.permanent.checked) {
          if (this.x !== this.baseX) this.x -= (this.x - this.baseX) / RETURN_SPEED;
          if (this.y !== this.baseY) this.y -= (this.y - this.baseY) / RETURN_SPEED;
        }
        this.x += this.vx; this.y += this.vy;
        this.vx *= 0.92; this.vy *= 0.92;
      }
    }

    function drawBackground(){
      const midX = innerWidth / 2;
      ctx.fillStyle = ui.bgLeft.value; ctx.fillRect(0,0,midX,innerHeight);
      ctx.fillStyle = ui.bgRight.value; ctx.fillRect(midX,0,innerWidth - midX, innerHeight);
    }

    function init() {
      ctx.clearRect(0,0,innerWidth,innerHeight);
      ctx.save();
      ctx.font = FONT();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      drawBackground();
      ctx.fillStyle = '#fff';
      ctx.shadowColor = 'rgba(0,0,0,.35)';
      ctx.shadowBlur = 6;
      ctx.fillText(WORD, innerWidth/2, innerHeight/2);
      ctx.restore();
      const img = ctx.getImageData(0, 0, innerWidth, innerHeight).data;
      particles = [];
      for (let y = 0; y < innerHeight; y += GAP) {
        for (let x = 0; x < innerWidth; x += GAP) {
          const i = (y * innerWidth + x) * 4;
          const alpha = img[i + 3];
          if (alpha > 128) particles.push(new Particle(x, y, ui.dotColor.value));
        }
      }
    }

    function animate() {
      ctx.clearRect(0,0,innerWidth,innerHeight);
      drawBackground();
      const grad = ctx.createLinearGradient(innerWidth*0.55,0,innerWidth,0);
      grad.addColorStop(0,'rgba(255,255,255,0)');
      grad.addColorStop(1,'rgba(255,255,255,0.08)');
      ctx.fillStyle = grad; ctx.fillRect(innerWidth*0.55,0,innerWidth*0.45,innerHeight);
      for (let p of particles) {
        p.size = SIZE;
        p.color = ui.dotColor.value;
        p.update(ui.permanent.checked);
        p.draw();
      }
      requestAnimationFrame(animate);
    }

    // UI bindings
    ui.resetBtn.addEventListener('click', init);
    ui.wordInput.addEventListener('input', () => { WORD = ui.wordInput.value || ' '; init(); });
    ui.fontSelect.addEventListener('change', init);
    ui.fontSize.addEventListener('input', init);
    ui.gap.addEventListener('input', () => { GAP = parseInt(ui.gap.value,10); init(); });
    ui.dotSize.addEventListener('input', () => { SIZE = parseInt(ui.dotSize.value,10); });
    ui.radius.addEventListener('input', () => { mouse.radius = parseFloat(ui.radius.value); });
    ui.returnSpeed.addEventListener('input', () => { RETURN_SPEED = parseFloat(ui.returnSpeed.value); });
    ui.scatter.addEventListener('input', () => { SCATTER = parseFloat(ui.scatter.value); });
    ui.dotColor.addEventListener('input', ()=>{});
    ui.bgLeft.addEventListener('input', init);
    ui.bgRight.addEventListener('input', init);

    // Presets
    const PRESETS = {
      "Solar": { dot:"#ffd166", left:"#1a1306", right:"#30210b", scatter:3.0, font:"Impact", music:"major" },
      "Noite Fria": { dot:"#cfe9ff", left:"#0a0f17", right:"#101825", scatter:2.4, font:"Montserrat", music:"calm" },
      "Sereno": { dot:"#ffffff", left:"#111111", right:"#e9e9e9", scatter:2.6, font:"Montserrat", music:"ambient" },
      "Neon": { dot:"#39ff88", left:"#0a0a0a", right:"#111133", scatter:4.2, font:"Impact", music:"major" },
      "Pastel": { dot:"#ffd4e5", left:"#1b181e", right:"#22202a", scatter:2.2, font:"Verdana", music:"calm" }
    };
    function applyPreset(name){
      const p = PRESETS[name]; if(!p) return;
      ui.dotColor.value = p.dot;
      ui.bgLeft.value = p.left; ui.bgRight.value = p.right;
      ui.scatter.value = p.scatter; SCATTER = p.scatter;
      ui.fontSelect.value = p.font;
      ui.musicMode.value = p.music;
      init();
      if (musicEngine) musicEngine.setMode(p.music);
    }
    ui.applyPreset.addEventListener('click', ()=> applyPreset(ui.presetSelect.value));

    // Start
    function start() { resize(); animate(); }
    start();

    // ====== Music engine ======
    let musicEngine = null;
    class Music {
      constructor(){
        this.ctx = new (window.AudioContext||window.webkitAudioContext)();
        this.master = this.ctx.createGain();
        this.master.gain.value = parseFloat(ui.vol.value);
        this.master.connect(this.ctx.destination);
        // tap for recording
        this.recDest = this.ctx.createMediaStreamDestination();
        this.master.connect(this.recDest);

        this.mode = ui.musicMode.value;
        this.loopHandle = null;
        this.userBuffer = null;
        this.userSource = null;
      }
      getStream(){ return this.recDest.stream; }
      setVolume(v){ this.master.gain.value = v; }
      setMode(m){ this.mode = m; }
      async start(){
        if (this.ctx.state === 'suspended') await this.ctx.resume();
        if (this.loopHandle) return;
        const loop = async ()=>{
          if (this.userBuffer){
            if (!this.userSource){
              const src = this.ctx.createBufferSource();
              src.buffer = this.userBuffer; src.loop = true;
              src.connect(this.master); src.start();
              this.userSource = src;
            }
            await new Promise(r=>setTimeout(r, 1000));
          } else {
            this.playMode();
            await this.sleep(8500);
          }
          this.loopHandle = requestAnimationFrame(loop);
        };
        loop();
      }
      stop(){
        if (this.loopHandle){ cancelAnimationFrame(this.loopHandle); this.loopHandle = null; }
        try{ this.userSource?.stop(); }catch{}
        this.userSource = null;
        try{ this.ctx.close(); }catch{}
      }
      sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
      note(freq, dur=2, gain=0.12, type='sine'){
        const t = this.ctx.currentTime;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(gain, t+0.1);
        g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
        o.connect(g); g.connect(this.master); o.start(); o.stop(t+dur);
      }
      pad(intervals=[0,4,7], seconds=8, base=220, type='sine', gain=0.10, lpFreq=800, noiseGain=0.05){
        for (const i of intervals){
          const freq = base * Math.pow(2, i/12);
          this.note(freq, seconds, gain, type);
        }
        const noise = this.ctx.createBuffer(1, this.ctx.sampleRate * seconds, this.ctx.sampleRate);
        const ch = noise.getChannelData(0);
        for (let i=0;i<ch.length;i++){ ch[i] = (Math.random()*2-1) * noiseGain; }
        const src = this.ctx.createBufferSource(); src.buffer = noise; 
        const nf = this.ctx.createBiquadFilter(); nf.type='lowpass'; nf.frequency.value=lpFreq;
        const g = this.ctx.createGain(); g.gain.value = noiseGain;
        src.connect(nf); nf.connect(g); g.connect(this.master);
        src.start(); src.stop(this.ctx.currentTime + seconds);
      }
      playMode(){
        const m = this.mode;
        if (m === 'major') this.pad([0,4,7], 8, 246, 'sine', 0.12, 1000, 0.04);
        else if (m === 'minor') this.pad([0,3,7], 8, 196, 'sine', 0.11, 900, 0.04);
        else if (m === 'calm')  this.pad([0,7], 10, 174, 'sine', 0.09, 600, 0.03);
        else                    this.pad([0,3,7,10], 8, 220, 'sine', 0.10, 800, 0.05);
      }
      bell(){
        const freqs = [880, 1320, 1760];
        let delay = 0;
        for (const f of freqs){
          const t = this.ctx.currentTime + delay;
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type='triangle'; o.frequency.value=f;
          g.gain.setValueAtTime(0.0001,t);
          g.gain.exponentialRampToValueAtTime(0.18, t+0.03);
          g.gain.exponentialRampToValueAtTime(0.0001, t+0.4);
          o.connect(g); g.connect(this.master);
          o.start(t); o.stop(t+0.45);
          delay += 0.05;
        }
      }
      async loadUserFile(file){
        const arr = await file.arrayBuffer();
        this.userBuffer = await this.ctx.decodeAudioData(arr);
      }
    }

    ui.musicToggle.addEventListener('click', async ()=>{
      if (!musicEngine){
        musicEngine = new Music();
        musicEngine.setMode(ui.musicMode.value);
        await musicEngine.start();
        ui.musicToggle.textContent = 'Parar';
      } else {
        musicEngine.stop(); musicEngine = null;
        ui.musicToggle.textContent = 'Tocar';
      }
    });
    ui.musicMode.addEventListener('change', ()=>{ musicEngine && musicEngine.setMode(ui.musicMode.value); });
    ui.vol.addEventListener('input', ()=>{ musicEngine && musicEngine.setVolume(parseFloat(ui.vol.value)); });
    ui.audioFile.addEventListener('change', async (e)=>{
      const file = e.target.files?.[0];
      if (!file) return;
      if (!musicEngine){ musicEngine = new Music(); }
      await musicEngine.loadUserFile(file);
      await musicEngine.start();
      ui.musicToggle.textContent = 'Parar';
    });

    // ====== Recording (canvas + app audio) ======
    let recorder = null, recChunks = [], recUrl = null;
    async function startRecording(){
      if (recorder) return;
      ui.recStatus.textContent = 'a prepararâ€¦'; ui.recStatus.className = 'pill warn';
      const fps = parseInt(ui.recFps.value,10);
      const canvasStream = canvas.captureStream(fps);
      const mixed = new MediaStream();
      // video
      const vtrack = canvasStream.getVideoTracks()[0];
      if (vtrack) mixed.addTrack(vtrack);
      // audio (app music)
      if (!musicEngine){ musicEngine = new Music(); await musicEngine.start(); ui.musicToggle.textContent='Parar'; }
      const audioStream = musicEngine.getStream();
      audioStream.getAudioTracks().forEach(t=> mixed.addTrack(t));
      // recorder
      let opts = { mimeType: 'video/webm;codecs=vp9,opus' };
      if (!MediaRecorder.isTypeSupported(opts.mimeType)) opts = { mimeType: 'video/webm;codecs=vp8,opus' };
      if (!MediaRecorder.isTypeSupported(opts.mimeType)) opts = { mimeType: 'video/webm' };
      recorder = new MediaRecorder(mixed, opts);
      recChunks = [];
      recorder.ondataavailable = e => { if(e.data && e.data.size) recChunks.push(e.data); };
      recorder.onstop = ()=>{
        const blob = new Blob(recChunks, {type: 'video/webm'});
        recUrl && URL.revokeObjectURL(recUrl);
        recUrl = URL.createObjectURL(blob);
        ui.recDownload.href = recUrl;
        ui.recDownload.style.display = 'inline-block';
        ui.recStatus.textContent = 'pronto para baixar'; ui.recStatus.className = 'pill ok';
      };
      recorder.start();
      ui.recStart.disabled = true; ui.recStop.disabled = false;
      ui.recStatus.textContent = 'a gravarâ€¦'; ui.recStatus.className = 'pill ok';
    }
    function stopRecording(){
      if (!recorder) return;
      recorder.stop();
      recorder = null;
      ui.recStart.disabled = false; ui.recStop.disabled = true;
    }
    ui.recStart.addEventListener('click', startRecording);
    ui.recStop.addEventListener('click', stopRecording);

    // Make sure audio can play after user gesture (iOS)
    ['click','keydown','touchstart'].forEach(ev=>{
      document.addEventListener(ev, async ()=>{
        try{ if (musicEngine?.ctx?.state === 'suspended') await musicEngine.ctx.resume(); }catch{}
      }, {passive:true});
    });

  </script>
</body>
</html>
