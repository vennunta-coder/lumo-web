<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>IMAGINATION â€” PRO (Emotion AI + MÃºsica)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --panel-bg: rgba(0,0,0,.55);
      --panel-text:#eee;
      --accent:#5be37d;
      --danger:#ff5d5d;
      --muted:#b9c1c7;
    }
    html, body { height: 100%; margin: 0; background:#111; overflow:hidden; }
    #ui {
      position: fixed; top: 12px; left: 12px; z-index: 10;
      font: 13.5px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: var(--panel-text); background: var(--panel-bg);
      padding: 10px 12px; border-radius: 12px; backdrop-filter: blur(6px);
      max-width: min(88vw, 420px);
    }
    #ui h1 { margin:0 0 6px; font-size:16px; letter-spacing:.3px }
    #ui .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:6px 0}
    #ui label{ display:flex; align-items:center; gap:6px; cursor:pointer; user-select:none }
    #ui input[type="text"]{ flex:1; padding:6px 8px; border-radius:8px; border:1px solid #333; background:#0b0b0b; color:#ddd }
    #ui input[type="range"]{ width:120px }
    #ui input[type="color"]{ width:36px; height:28px; padding:0; border:0; background:transparent; }
    #ui select{ padding:6px 8px; border-radius:8px; border:1px solid #333; background:#0b0b0b; color:#ddd }
    #ui button {
      padding: 6px 10px; border: 0; border-radius: 8px; cursor: pointer; background:#1d1d1d; color:#eaeaea;
    }
    #ui .pill { padding:4px 8px; border-radius:999px; font-size:12px; }
    #ui .ok { background:#163e24; color:#89f5a8; }
    #ui .warn { background:#3e2a16; color:#f5c189; }
    #ui .err { background:#3e1616; color:#ff9b9b; }
    #emoPhrase { margin-top:6px; font-size:13px; color:#dfe; min-height:1.4em }
    #credit { position:fixed; right:12px; bottom:12px; color:#7a7a7a; font: 12px system-ui; z-index:10; background:rgba(0,0,0,.4); padding:6px 8px; border-radius:8px }

    canvas { display:block; }

    /* Tiny overlay canvas for face landmarks (optional) */
    #overlay {
      position:fixed; inset:0; pointer-events:none; z-index:5;
    }

    /* Floating indicators */
    .badge {
      position:fixed; top:12px; right:12px; z-index:10; padding:6px 10px; border-radius:999px;
      background:rgba(0,0,0,.45); color:#d6ffd6; font:12px system-ui; display:flex; align-items:center; gap:6px;
    }
  </style>
</head>
<body>
  <div id="ui">
    <h1>IMAGINATION â€” PRO</h1>

    <div class="row">
      <input id="wordInput" type="text" value="IMAGINATION" />
      <button id="resetBtn">Reset</button>
    </div>

    <div class="row">
      <label>Fonte
        <select id="fontSelect">
          <option value="Arial Black" selected>Arial Black</option>
          <option value="Impact">Impact</option>
          <option value="Montserrat">Montserrat</option>
          <option value="Verdana">Verdana</option>
        </select>
      </label>
      <label>Tamanho <input id="fontSize" type="range" min="60" max="220" value="120" /></label>
    </div>

    <div class="row">
      <label>PartÃ­culas <input id="gap" type="range" min="2" max="10" value="4" /></label>
      <label>Tamanho <input id="dotSize" type="range" min="1" max="5" value="2" /></label>
    </div>

    <div class="row">
      <label>Raio rato <input id="radius" type="range" min="40" max="200" value="90" /></label>
      <label>Retorno <input id="returnSpeed" type="range" min="5" max="50" value="20" /></label>
      <label>Scatter <input id="scatter" type="range" min="0.5" max="6" step="0.1" value="2.6" /></label>
    </div>

    <div class="row">
      <label>Cor partÃ­cula <input id="dotColor" type="color" value="#ffffff" /></label>
      <label>BG esquerda <input id="bgLeft" type="color" value="#111111" /></label>
      <label>BG direita <input id="bgRight" type="color" value="#e9e9e9" /></label>
      <label><input id="permanent" type="checkbox"> Permanente</label>
    </div>

    <div class="row" style="border-top:1px solid #2a2a2a; padding-top:8px; margin-top:8px">
      <strong>Emotion AI</strong>
      <button id="emotionToggle">Ativar cÃ¢mara</button>
      <span id="aiStatus" class="pill warn">parado</span>
      <label><input id="showOverlay" type="checkbox"> overlay</label>
    </div>
    <div id="emoPhrase"></div>

    <div class="row" style="border-top:1px solid #2a2a2a; padding-top:8px; margin-top:8px">
      <strong>MÃºsica</strong>
      <button id="musicToggle">Tocar</button>
      <label>Vol <input id="vol" type="range" min="0" max="1" step="0.01" value="0.25" /></label>
      <input id="audioFile" type="file" accept="audio/*" />
    </div>
  </div>

  <div id="credit">Privado: a cÃ¢mara e o microfone (se usados) ficam no dispositivo. Sem upload.</div>
  <div class="badge" id="emotionBadge" style="display:none">ðŸ™‚ neutro</div>

  <canvas id="c"></canvas>
  <canvas id="overlay"></canvas>

  <video id="video" playsinline autoplay muted style="display:none"></video>

  <script type="module">
    // ===== Canvas particles (based on your original) =====
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const octx = overlay.getContext('2d');
    const ui = {
      wordInput: document.getElementById('wordInput'),
      resetBtn: document.getElementById('resetBtn'),
      fontSelect: document.getElementById('fontSelect'),
      fontSize: document.getElementById('fontSize'),
      gap: document.getElementById('gap'),
      dotSize: document.getElementById('dotSize'),
      radius: document.getElementById('radius'),
      returnSpeed: document.getElementById('returnSpeed'),
      scatter: document.getElementById('scatter'),
      dotColor: document.getElementById('dotColor'),
      bgLeft: document.getElementById('bgLeft'),
      bgRight: document.getElementById('bgRight'),
      permanent: document.getElementById('permanent'),
      showOverlay: document.getElementById('showOverlay'),
      emotionToggle: document.getElementById('emotionToggle'),
      aiStatus: document.getElementById('aiStatus'),
      emoPhrase: document.getElementById('emoPhrase'),
      musicToggle: document.getElementById('musicToggle'),
      vol: document.getElementById('vol'),
      audioFile: document.getElementById('audioFile'),
      emotionBadge: document.getElementById('emotionBadge')
    };

    function resize() {
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      for (const cvs of [canvas, overlay]) {
        cvs.width = innerWidth * dpr;
        cvs.height = innerHeight * dpr;
        cvs.style.width = innerWidth + 'px';
        cvs.style.height = innerHeight + 'px';
        const ctx2d = cvs.getContext('2d');
        ctx2d.setTransform(dpr,0,0,dpr,0,0);
      }
      init();
    }
    window.addEventListener('resize', resize);

    const mouse = { x: -9999, y: -9999, radius: parseFloat(ui.radius.value) };
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mouseleave', () => { mouse.x = -9999; mouse.y = -9999; });

    let particles = [];
    let WORD = ui.wordInput.value;
    let FONT = () => `bold ${ui.fontSize.value}px ${ui.fontSelect.value}`;
    let GAP = parseInt(ui.gap.value,10);
    let SIZE = parseInt(ui.dotSize.value,10);
    let RETURN_SPEED = parseFloat(ui.returnSpeed.value);
    let SCATTER = parseFloat(ui.scatter.value);

    class Particle {
      constructor(x, y, color='white') {
        this.baseX = x; this.baseY = y;
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.size = SIZE;
        this.color = color;
        this.alpha = 1;
        this.dead = false;
        this.density = Math.random()*40 + 10;
      }
      draw() {
        if (this.dead) return;
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
      }
      update(permanent) {
        if (this.dead) return;

        const dx = mouse.x - this.x;
        const dy = mouse.y - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist < mouse.radius) {
          const force = (mouse.radius - dist) / mouse.radius;
          const dirX = dx / (dist || 1);
          const dirY = dy / (dist || 1);

          this.x -= dirX * force * this.density;
          this.y -= dirY * force * this.density;

          this.vx -= dirX * SCATTER * Math.random();
          this.vy -= dirY * SCATTER * Math.random();

          if (ui.permanent.checked) {
            this.alpha = Math.max(0, this.alpha - 0.08);
            if (this.alpha <= 0.02) this.dead = true;
          }
        } else if (!ui.permanent.checked) {
          if (this.x !== this.baseX) this.x -= (this.x - this.baseX) / RETURN_SPEED;
          if (this.y !== this.baseY) this.y -= (this.y - this.baseY) / RETURN_SPEED;
        }

        this.x += this.vx; this.y += this.vy;
        this.vx *= 0.92; this.vy *= 0.92;
      }
    }

    function init() {
      ctx.clearRect(0,0,innerWidth,innerHeight);
      ctx.save();
      ctx.font = FONT();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // split background using color pickers
      const midX = innerWidth / 2;
      ctx.fillStyle = ui.bgLeft.value; ctx.fillRect(0,0,midX,innerHeight);
      ctx.fillStyle = ui.bgRight.value; ctx.fillRect(midX,0,innerWidth - midX, innerHeight);

      ctx.fillStyle = '#fff';
      ctx.shadowColor = 'rgba(0,0,0,.35)';
      ctx.shadowBlur = 6;
      ctx.fillText(WORD, innerWidth/2, innerHeight/2);
      ctx.restore();

      const img = ctx.getImageData(0, 0, innerWidth, innerHeight).data;

      particles = [];
      for (let y = 0; y < innerHeight; y += GAP) {
        for (let x = 0; x < innerWidth; x += GAP) {
          const i = (y * innerWidth + x) * 4;
          const alpha = img[i + 3];
          if (alpha > 128) particles.push(new Particle(x, y, ui.dotColor.value));
        }
      }
    }

    function animate() {
      ctx.clearRect(0,0,innerWidth,innerHeight);

      // glossy fog on right
      const grad = ctx.createLinearGradient(innerWidth*0.55,0,innerWidth,0);
      grad.addColorStop(0,'rgba(255,255,255,0)');
      grad.addColorStop(1,'rgba(255,255,255,0.08)');
      ctx.fillStyle = grad; ctx.fillRect(innerWidth*0.55,0,innerWidth*0.45,innerHeight);

      // background again (so particles render on top)
      const midX = innerWidth / 2;
      ctx.fillStyle = ui.bgLeft.value; ctx.fillRect(0,0,midX,innerHeight);
      ctx.fillStyle = ui.bgRight.value; ctx.fillRect(midX,0,innerWidth - midX, innerHeight);

      for (let p of particles) {
        p.size = SIZE;
        p.color = ui.dotColor.value;
        p.update(ui.permanent.checked);
        p.draw();
      }
      requestAnimationFrame(animate);
    }

    // UI bindings
    ui.resetBtn.addEventListener('click', init);
    ui.wordInput.addEventListener('input', () => { WORD = ui.wordInput.value || ' '; init(); });
    ui.fontSelect.addEventListener('change', init);
    ui.fontSize.addEventListener('input', init);
    ui.gap.addEventListener('input', () => { GAP = parseInt(ui.gap.value,10); init(); });
    ui.dotSize.addEventListener('input', () => { SIZE = parseInt(ui.dotSize.value,10); });
    ui.radius.addEventListener('input', () => { mouse.radius = parseFloat(ui.radius.value); });
    ui.returnSpeed.addEventListener('input', () => { RETURN_SPEED = parseFloat(ui.returnSpeed.value); });
    ui.scatter.addEventListener('input', () => { SCATTER = parseFloat(ui.scatter.value); });
    ui.dotColor.addEventListener('input', ()=>{});
    ui.bgLeft.addEventListener('input', init);
    ui.bgRight.addEventListener('input', init);

    // kick off
    function start() { resize(); animate(); }
    start();

    // ====== Emotion AI (on-device, camera) ======
    const video = document.getElementById('video');
    let faceLandmarker = null;
    let running = false;

    async function initFaceAI(){
      try{
        ui.aiStatus.textContent = 'a carregarâ€¦';
        ui.aiStatus.className = 'pill warn';
        const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest');
        const {FaceLandmarker, FilesetResolver} = vision;
        const resolver = await FilesetResolver.forVisionTasks(
          'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'
        );
        faceLandmarker = await FaceLandmarker.createFromOptions(resolver, {
          baseOptions: {
            modelAssetPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm/face_landmarker.task'
          },
          runningMode: 'VIDEO',
          numFaces: 1,
          outputFaceBlendshapes: false
        });
        ui.aiStatus.textContent = 'pronto';
        ui.aiStatus.className = 'pill ok';
      }catch(err){
        console.error(err);
        ui.aiStatus.textContent = 'falhou';
        ui.aiStatus.className = 'pill err';
        alert('Falha ao carregar o modelo de detecÃ§Ã£o facial. Verifica a internet e tenta novamente.');
        throw err;
      }
    }

    async function startCamera(){
      const stream = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
      video.srcObject = stream;
      await video.play();
    }

    // Simple heuristic over MediaPipe FaceMesh landmarks to infer emotions:
    // - alegria: boca relativamente larga vs largura da face (sorriso)
    // - surpresa: boca muito aberta (ratio alto)
    // - neutro: caso contrÃ¡rio
    function classifyEmotion(landmarks){
      // Common landmark indices (FaceMesh):
      // mouth corners: 61 (left), 291 (right)
      // inner lip: 13 (top), 14 (bottom)
      // face width ref: 33 (left eye outer) and 263 (right eye outer)
      const L = (i)=>landmarks[i];
      const dist = (a,b)=> Math.hypot(a.x-b.x, a.y-b.y);
      const mouthW = dist(L(61), L(291));
      const mouthOpen = dist(L(13), L(14));
      const faceW = dist(L(33), L(263)) || 1;

      const widthNorm = mouthW / faceW;
      const openNorm = mouthOpen / faceW;

      // Heuristic thresholds (tuned empirically)
      if (openNorm > 0.35) return {label:'surpresa', score: openNorm};
      if (widthNorm > 0.52 && openNorm < 0.28) return {label:'alegria', score: widthNorm};
      return {label:'neutro', score: 1-widthNorm};
    }

    function setEmotionUI(em){
      const badge = ui.emotionBadge;
      const map = {
        alegria: 'ðŸ˜„ alegria',
        surpresa: 'ðŸ˜® surpresa',
        neutro: 'ðŸ™‚ neutro'
      };
      badge.textContent = map[em] || 'ðŸ™‚ neutro';
      badge.style.display = 'block';

      // Empathetic phrase
      let phrase = '';
      if (em === 'alegria') phrase = 'Que bom ver esse sorriso! ðŸŒž Que a tua alegria contagie o resto do dia.';
      else if (em === 'surpresa') phrase = 'Uau! Algo te surpreendeu? Estou contigo â€” respira e aprecia o momento. âœ¨';
      else phrase = 'TÃ´ aqui contigo. Se quiseres, posso dar um toque de inspiraÃ§Ã£o ou mÃºsica suave. ðŸŒ¿';
      ui.emoPhrase.textContent = phrase;

      // Visual & music responses
      if (em === 'alegria'){
        ui.dotColor.value = '#ffd166';   // warm
        ui.bgLeft.value = '#0f1a10'; ui.bgRight.value = '#1c2a1d';
        SCATTER = 3.2;
        musicEngine && musicEngine.setMode('major');
      } else if (em === 'surpresa'){
        ui.dotColor.value = '#f6f1d1';
        ui.bgLeft.value = '#100f1a'; ui.bgRight.value = '#221d2a';
        SCATTER = 4.0;
        musicEngine && musicEngine.bell();
      } else {
        ui.dotColor.value = '#ffffff';
        ui.bgLeft.value = '#111111'; ui.bgRight.value = '#e9e9e9';
        SCATTER = parseFloat(document.getElementById('scatter').value);
        musicEngine && musicEngine.setMode('ambient');
      }
      init();
    }

    let rafId = 0;
    function drawOverlay(res){
      if(!ui.showOverlay.checked){ octx.clearRect(0,0,overlay.width, overlay.height); return; }
      octx.clearRect(0,0,innerWidth,innerHeight);
      if(!res || !res.faceLandmarks?.length) return;
      const pts = res.faceLandmarks[0];
      octx.strokeStyle = 'rgba(144,255,144,.8)';
      octx.lineWidth = 1.5;
      octx.beginPath();
      for (const p of pts) octx.lineTo(p.x * innerWidth, p.y * innerHeight);
      octx.stroke();
    }

    async function loopFace(){
      if (!running || !faceLandmarker) return;
      const ts = performance.now();
      const res = faceLandmarker.detectForVideo(video, ts);
      if (res?.faceLandmarks?.length){
        drawOverlay(res);
        const emo = classifyEmotion(res.faceLandmarks[0]);
        setEmotionUI(emo.label);
      }
      rafId = requestAnimationFrame(loopFace);
    }

    ui.emotionToggle.addEventListener('click', async ()=>{
      try{
        if (running){
          running = false;
          cancelAnimationFrame(rafId);
          ui.emotionToggle.textContent = 'Ativar cÃ¢mara';
          ui.aiStatus.textContent = 'parado'; ui.aiStatus.className = 'pill warn';
          ui.emotionBadge.style.display='none';
          return;
        }
        if (!faceLandmarker) await initFaceAI();
        await startCamera();
        running = true;
        ui.emotionToggle.textContent = 'Parar';
        ui.aiStatus.textContent = 'a detetarâ€¦'; ui.aiStatus.className = 'pill ok';
        loopFace();
      }catch(e){
        console.error(e);
        ui.aiStatus.textContent = 'erro';
        ui.aiStatus.className = 'pill err';
      }
    });

    // ====== Music engine (WebAudio, no external files) ======
    let musicEngine = null;
    class Music {
      constructor(){
        this.ctx = new (window.AudioContext||window.webkitAudioContext)();
        this.master = this.ctx.createGain();
        this.master.gain.value = parseFloat(ui.vol.value);
        this.master.connect(this.ctx.destination);
        this.mode = 'ambient';
        this.loopHandle = null;
        this.userBuffer = null; // user audio file
      }
      setVolume(v){ this.master.gain.value = v; }
      setMode(m){ this.mode = m; }
      async start(){
        if (this.ctx.state === 'suspended') await this.ctx.resume();
        if (this.loopHandle) return;
        const loop = async ()=>{
          if (this.userBuffer){
            // If user loaded a track, ensure it loops
            const src = this.ctx.createBufferSource();
            src.buffer = this.userBuffer; src.loop = true;
            src.connect(this.master); src.start();
            await new Promise(r=>setTimeout(r, Math.ceil(this.userBuffer.duration*1000)));
          } else {
            if (this.mode === 'major') this.playPad([0,4,7], 8);     // C major triad
            else this.playPad([0,3,7], 8);                           // C minor-ish
            await this.sleep(8500);
          }
          this.loopHandle = requestAnimationFrame(loop);
        };
        loop();
      }
      stop(){
        if (this.loopHandle){ cancelAnimationFrame(this.loopHandle); this.loopHandle = null; }
        try{ this.ctx.close(); }catch{}
      }
      sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
      note(freq, dur=2, gain=0.12){
        const t = this.ctx.currentTime;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = 'sine';
        o.frequency.value = freq;
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(gain, t+0.1);
        g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
        o.connect(g); g.connect(this.master); o.start(); o.stop(t+dur);
      }
      playPad(intervals=[0,4,7], seconds=8){
        const base = 220; // A3-ish
        for (const i of intervals){
          const freq = base * Math.pow(2, i/12);
          this.note(freq, seconds, 0.10);
        }
        // a gentle noise bed
        const noise = this.ctx.createBuffer(1, this.ctx.sampleRate * seconds, this.ctx.sampleRate);
        const ch = noise.getChannelData(0);
        for (let i=0;i<ch.length;i++){ ch[i] = (Math.random()*2-1) * 0.02; }
        const src = this.ctx.createBufferSource(); src.buffer = noise; 
        const nf = this.ctx.createBiquadFilter(); nf.type='lowpass'; nf.frequency.value=800;
        const g = this.ctx.createGain(); g.gain.value = 0.05;
        src.connect(nf); nf.connect(g); g.connect(this.master);
        src.start(); src.stop(this.ctx.currentTime + seconds);
      }
      bell(){
        // one-shot chime
        const freqs = [880, 1320, 1760];
        let delay = 0;
        for (const f of freqs){
          const t = this.ctx.currentTime + delay;
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type='triangle'; o.frequency.value=f;
          g.gain.setValueAtTime(0.0001,t);
          g.gain.exponentialRampToValueAtTime(0.18, t+0.03);
          g.gain.exponentialRampToValueAtTime(0.0001, t+0.4);
          o.connect(g); g.connect(this.master);
          o.start(t); o.stop(t+0.45);
          delay += 0.05;
        }
      }
      async loadUserFile(file){
        const arr = await file.arrayBuffer();
        this.userBuffer = await this.ctx.decodeAudioData(arr);
      }
    }

    ui.musicToggle.addEventListener('click', async ()=>{
      if (!musicEngine){
        musicEngine = new Music();
        await musicEngine.start();
        ui.musicToggle.textContent = 'Parar';
      } else {
        musicEngine.stop(); musicEngine = null;
        ui.musicToggle.textContent = 'Tocar';
      }
    });
    ui.vol.addEventListener('input', ()=>{ musicEngine && musicEngine.setVolume(parseFloat(ui.vol.value)); });
    ui.audioFile.addEventListener('change', async (e)=>{
      const file = e.target.files?.[0];
      if (!file) return;
      if (!musicEngine){ musicEngine = new Music(); }
      await musicEngine.loadUserFile(file);
      await musicEngine.start();
      ui.musicToggle.textContent = 'Parar';
    });

    // Make sure audio can play after user gesture on iOS
    ['click','keydown','touchstart'].forEach(ev=>{
      document.addEventListener(ev, async ()=>{
        try{ if (musicEngine?.ctx?.state === 'suspended') await musicEngine.ctx.resume(); }catch{}
      }, {passive:true});
    });

    // Initial overlay state
    ui.showOverlay.checked = false;

  </script>
</body>
</html>
